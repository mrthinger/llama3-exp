{"date": "2024-05-11 03:01", "hash": "84f4b93a1270b492e4c54d5212da7a5b", "eval": {"HumanEval/10": [{"task_id": "HumanEval/10", "solution": "def make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    \"\"\"\n    for i in range(len(string) - 1, -1, -1):\n        if is_palindrome(string[i:]):\n            return string + string[:i][::-1]\n    return string + string[::-1]", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [["x"]], "plus_fail_tests": []}], "HumanEval/6": [{"task_id": "HumanEval/6", "solution": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\"\n    Parse a string of multiple groups of nested parentheses, separated by spaces.\n    Return a list of integers, where each integer represents the maximum level of nesting for each group.\n\n    :param paren_string: a string of multiple groups of nested parentheses, separated by spaces\n    :return: a list of integers, where each integer represents the maximum level of nesting for each group\n    \"\"\"\n    def max_nesting(group: str) -> int:\n        \"\"\"Helper function to calculate the max nesting level for a single group of parentheses\"\"\"\n        max_level = 0\n        curr_level = 0\n        for c in group:\n            if c == '(':\n                curr_level += 1\n                max_level = max(max_level, curr_level)\n            elif c == ')':\n                curr_level -= 1\n        return max_level\n\n    # Split the input string into individual groups\n    groups = paren_string.split()\n\n    # Calculate the max nesting level for each group and return the results as a list\n    return [max_nesting(group) for group in groups]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/5": [{"task_id": "HumanEval/5", "solution": "from typing import List\n\ndef intersperse(numbers: List[int], delimiter: int) -> List[int]:\n    result = []\n    for i, num in enumerate(numbers):\n        result.append(num)\n        if i < len(numbers) - 1:\n            result.append(delimiter)\n    return result", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/7": [{"task_id": "HumanEval/7", "solution": "from typing import List\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    return [s for s in strings if substring in s]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/3": [{"task_id": "HumanEval/3", "solution": "from typing import List\n\ndef below_zero(operations: List[int]) -> bool:\n    balance = 0\n    for op in operations:\n        balance += op\n        if balance < 0:\n            return True\n    return False", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/12": [{"task_id": "HumanEval/12", "solution": "from typing import List, Optional\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    \"\"\"\n    if not strings:\n        return None\n    return max(strings, key=len)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/13": [{"task_id": "HumanEval/13", "solution": "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\"\n    Return the greatest common divisor of two integers a and b\n    \"\"\"\n    while b:\n        a, b = b, a % b\n    return a", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/0": [{"task_id": "HumanEval/0", "solution": "from typing import List\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\"\n    Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n\n    Args:\n        numbers (List[float]): A list of floating point numbers\n        threshold (float): The maximum allowed distance between two numbers\n\n    Returns:\n        bool: True if any two numbers are closer than the threshold, False otherwise\n    \"\"\"\n    numbers = sorted(numbers)  # Sort the list of numbers\n    for i in range(len(numbers) - 1):\n        if numbers[i + 1] - numbers[i] < threshold:\n            return True\n    return False", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/4": [{"task_id": "HumanEval/4", "solution": "from typing import List\nimport statistics\n\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\"\n    For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    \"\"\"\n    # Calculate the mean of the input numbers\n    mean = statistics.mean(numbers)\n    \n    # Calculate the absolute differences between each number and the mean\n    abs_diffs = [abs(x - mean) for x in numbers]\n    \n    # Calculate the mean of the absolute differences\n    mad = sum(abs_diffs) / len(abs_diffs)\n    \n    return mad", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[2.109160016548039, 1.5, 2.0, 2.5, 3.0, 3.5, 4.0]]]}], "HumanEval/11": [{"task_id": "HumanEval/11", "solution": "from typing import List\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\"\n    Perform binary XOR on two input strings a and b consisting only of 1s and 0s.\n    Return the result as a string.\n    \"\"\"\n    result = [str(int(x) ^ int(y)) for x, y in zip(a, b)]\n    return ''.join(result)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/1": [{"task_id": "HumanEval/1", "solution": "from typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\"\n    Separate groups of balanced parentheses into separate strings.\n\n    Args:\n        paren_string (str): Input string containing multiple groups of balanced parentheses.\n\n    Returns:\n        List[str]: List of separate strings, each containing a balanced group of parentheses.\n    \"\"\"\n    result = []\n    current_group = \"\"\n    level = 0\n\n    for char in paren_string.replace(\" \", \"\"):\n        if char == \"(\":\n            level += 1\n        elif char == \")\":\n            level -= 1\n\n        current_group += char\n\n        if level == 0:\n            result.append(current_group)\n            current_group = \"\"\n\n    return result", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/8": [{"task_id": "HumanEval/8", "solution": "from typing import List, Tuple\nimport math\nimport functools\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\"\n    For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    \"\"\"\n    if not numbers:\n        return 0, 1\n    else:\n        return sum(numbers), math.prod(numbers) if hasattr(math, 'prod') else functools.reduce(lambda x, y: x * y, numbers)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/2": [{"task_id": "HumanEval/2", "solution": "def truncate_number(number: float) -> float:\n    return number - int(number)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/9": [{"task_id": "HumanEval/9", "solution": "from typing import List\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\"\n    From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    result = []\n    max_so_far = float('-inf')\n    for num in numbers:\n        max_so_far = max(max_so_far, num)\n        result.append(max_so_far)\n    return result", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/14": [{"task_id": "HumanEval/14", "solution": "from typing import List\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\"\"\"\n    return [string[:i+1] for i in range(len(string))]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/31": [{"task_id": "HumanEval/31", "solution": "def is_prime(n):\n    if n <= 1:\n        return False\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    return True", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/17": [{"task_id": "HumanEval/17", "solution": "from typing import List\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\"\n    Parse a string of musical notes in a special ASCII format and return a list of integers\n    representing the number of beats each note lasts.\n\n    Legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quarter note, lasts one beat\n    \"\"\"\n    note_durations = {'o': 4, 'o|': 2, '.|': 1}\n    music_notes = music_string.split()\n    return [note_durations[note] for note in music_notes]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/46": [{"task_id": "HumanEval/46", "solution": "def fib4(n: int) -> int:\n    if n <= 1:\n        return 0\n    elif n == 2:\n        return 2\n    elif n == 3:\n        return 0\n\n    a, b, c, d = 0, 0, 2, 0\n    for _ in range(4, n+1):\n        a, b, c, d = b, c, d, a + b + c + d\n    return d", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/16": [{"task_id": "HumanEval/16", "solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of \"\"\"\n    return len(set(c.casefold() for c in string))", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/33": [{"task_id": "HumanEval/33", "solution": "def sort_third(l: list) -> list:\n    \"\"\"\n    This function takes a list l and returns a list l' such that\n    l' is identical to l in the indices that are not divisible by three, while its values at the indices that are divisible by three are equal\n    to the values of the corresponding indices of l, but sorted.\n    \"\"\"\n    result = []\n    temp = []\n    for i, x in enumerate(l):\n        if i % 3 == 0:\n            temp.append(x)\n        else:\n            result.append(x)\n            if temp:\n                result.extend(sorted(temp))\n                temp = []\n    if temp:\n        result.extend(sorted(temp))\n    return result", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/41": [{"task_id": "HumanEval/41", "solution": "def car_race_collision(n: int) -> int:\n    \"\"\"\n    Calculate the number of collisions between two sets of n cars moving in opposite directions.\n\n    Args:\n        n (int): The number of cars in each set.\n\n    Returns:\n        int: The total number of collisions.\n    \"\"\"\n    return n * (n - 1) // 2 + n * (n - 1) // 2", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/52": [{"task_id": "HumanEval/52", "solution": "def below_threshold(l: list, t: int) -> bool:\n    \"\"\"Return True if all numbers in the list l are below threshold t.\"\"\"\n    return all(x < t for x in l)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/44": [{"task_id": "HumanEval/44", "solution": "def change_base(x: int, base: int) -> str:\n    \"\"\"\n    Change numerical base of input number x to base.\n    Return string representation after the conversion.\n    Base numbers are less than 10.\n    \"\"\"\n    if not 2 <= base <= 9:\n        raise ValueError(\"Base must be between 2 and 9\")\n    result = \"\"\n    while x > 0:\n        x, remainder = divmod(x, base)\n        result = str(remainder) + result\n    return result", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[0, 3]]}], "HumanEval/54": [{"task_id": "HumanEval/54", "solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n    \"\"\"\n    return sorted(s0) == sorted(s1)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [["aaabbbccc", "abbabcbc"]]}], "HumanEval/56": [{"task_id": "HumanEval/56", "solution": "def correct_bracketing(brackets: str) -> bool:\n    \"\"\"\n    Return True if every opening bracket has a corresponding closing bracket.\n    \"\"\"\n    stack = []\n    for bracket in brackets:\n        if bracket == \"<\":\n            stack.append(bracket)\n        elif bracket == \">\":\n            if not stack:\n                return False\n            stack.pop()\n    return not stack", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/26": [{"task_id": "HumanEval/26", "solution": "from typing import List\nfrom collections import OrderedDict\n\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    \"\"\"\n    return list(OrderedDict.fromkeys(num for num in numbers if numbers.count(num) == 1))", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/19": [{"task_id": "HumanEval/19", "solution": "from typing import List, Dict\n\ndef sort_numbers(numbers: str) -> str:\n    \"\"\"\n    Input is a space-delimited string of numberals from 'zero' to 'nine'.\n    Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n    Return the string with numbers sorted from smallest to largest\n    \"\"\"\n    num_map: Dict[str, int] = {\n        'zero': 0, 'one': 1, 'two': 2, 'three': 3, 'four': 4,\n        'five': 5, 'six': 6, 'seven': 7, 'eight': 8, 'nine': 9\n    }\n    num_list: List[str] = numbers.split()\n    num_list.sort(key=lambda x: num_map[x])\n    return ' '.join(num_list)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/21": [{"task_id": "HumanEval/21", "solution": "from typing import List\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\"\n    Given a list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1.\n\n    Args:\n        numbers: A list of floats with at least two elements.\n\n    Returns:\n        A new list of floats, where the smallest number is 0 and the largest is 1.\n    \"\"\"\n    min_val = min(numbers)\n    max_val = max(numbers)\n    range_val = max_val - min_val\n    return [(x - min_val) / range_val for x in numbers]", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[0.1, 0.5, 0.9, 0.3, 0.7]]]}], "HumanEval/53": [{"task_id": "HumanEval/53", "solution": "def add(x: int, y: int) -> int:\n    \"\"\"Add two numbers x and y\"\"\"\n    return x + y", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/59": [{"task_id": "HumanEval/59", "solution": "def largest_prime_factor(n: int):\n    \"\"\"\n    Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    \"\"\"\n    def is_prime(m: int) -> bool:\n        \"\"\"\n        Helper function to check if a number is prime.\n        \"\"\"\n        if m <= 1:\n            return False\n        for i in range(2, int(m ** 0.5) + 1):\n            if m % i == 0:\n                return False\n        return True\n\n    # Initialize the largest prime factor\n    largest_prime = 1\n\n    # Iterate from 2 to sqrt(n)\n    for i in range(2, int(n ** 0.5) + 1):\n        # Check if i is a factor of n\n        while n % i == 0:\n            # If i is prime, update the largest prime factor\n            if is_prime(i):\n                largest_prime = i\n            # Divide n by i\n            n //= i\n\n    # If n is a prime number greater than 2, update the largest prime factor\n    if n > 2 and is_prime(n):\n        largest_prime = n\n\n    return largest_prime", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/45": [{"task_id": "HumanEval/45", "solution": "def triangle_area(a, h):\n    \"\"\"Given length of a side and high return area for a triangle.\"\"\"\n    return 0.5 * a * h", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/42": [{"task_id": "HumanEval/42", "solution": "def incr_list(l: list) -> list:\n    \"\"\"Return list with elements incremented by 1.\"\"\"\n    return [x + 1 for x in l]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/28": [{"task_id": "HumanEval/28", "solution": "from typing import List\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\"\"\"\n    return ''.join(strings)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/32": [{"task_id": "HumanEval/32", "solution": "import math\nimport cmath\n\ndef find_zero(xs: list):\n    \"\"\"\n    Find a zero of the polynomial with coefficients xs.\n    Only works for polynomials with an even number of coefficients\n    and a non-zero leading coefficient, which guarantees a real solution.\n    Returns one zero point, even if there are many.\n    \"\"\"\n    # Check if the number of coefficients is even\n    if len(xs) % 2 != 0:\n        raise ValueError(\"Number of coefficients must be even\")\n\n    # Check if the leading coefficient is non-zero\n    if xs[-1] == 0:\n        raise ValueError(\"Leading coefficient must be non-zero\")\n\n    # Use the Newton-Raphson method to find a zero\n    x0 = 0.0  # initial guess\n    for _ in range(1000):  # max 1000 iterations\n        x1 = x0 - poly(xs, x0) / poly_prime(xs, x0)\n        if abs(x1 - x0) < 1e-12:  # convergence criterion\n            return x1.real\n        x0 = x1\n\n    raise RuntimeError(\"Failed to find a zero after 1000 iterations\")\n\ndef poly(xs: list, x: float):\n    \"\"\"\n    Evaluates polynomial with coefficients xs at point x.\n    return xs[0] + xs[1] * x + xs[1] * x^2 + .... xs[n] * x^n\n    \"\"\"\n    return sum([coeff * math.pow(x, i) for i, coeff in enumerate(xs)])\n\ndef poly_prime(xs: list, x: float):\n    \"\"\"\n    Evaluates derivative of polynomial with coefficients xs at point x.\n    return xs[1] + 2 * xs[2] * x + 3 * xs[3] * x^2 + .... n * xs[n] * x^(n-1)\n    \"\"\"\n    return sum([i * coeff * math.pow(x, i-1) for i, coeff in enumerate(xs) if i > 0])", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[-3, -6, -7, 7]]], "plus_fail_tests": []}], "HumanEval/51": [{"task_id": "HumanEval/51", "solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes a string and returns a string without vowels.\n    \"\"\"\n    vowels = 'aeiouAEIOU'\n    return ''.join([c for c in text if c not in vowels])", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/49": [{"task_id": "HumanEval/49", "solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware of numerics).\"\"\"\n    return pow(2, n, p)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/22": [{"task_id": "HumanEval/22", "solution": "from typing import List, Any\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers \"\"\"\n    return [x for x in values if isinstance(x, int)]", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[true, false, null, 0, -10, "test", [], {}, 3.14]]]}], "HumanEval/57": [{"task_id": "HumanEval/57", "solution": "def monotonic(l: list) -> bool:\n    \"\"\"\n    Return True if list elements are monotonically increasing or decreasing.\n    \"\"\"\n    return all(l[i] <= l[i+1] for i in range(len(l)-1)) or all(l[i] >= l[i+1] for i in range(len(l)-1))", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/18": [{"task_id": "HumanEval/18", "solution": "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlapping cases.\"\"\"\n    return sum(1 for i in range(len(string)) if string.startswith(substring, i))", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/67": [{"task_id": "HumanEval/67", "solution": "def fruit_distribution(s, n):\n    \"\"\"\n    Returns the number of mango fruits in the basket given a string representing the number of apples and oranges and the total number of fruits.\n\n    Args:\n        s (str): A string representing the number of apples and oranges, e.g. \"5 apples and 6 oranges\"\n        n (int): The total number of fruits in the basket\n\n    Returns:\n        int: The number of mango fruits in the basket\n    \"\"\"\n    # Split the input string into two parts: \"X apples\" and \"Y oranges\"\n    parts = s.split(\" and \")\n    # Extract the numbers of apples and oranges from the strings\n    num_apples = int(parts[0].split()[0])\n    num_oranges = int(parts[1].split()[0])\n    # Calculate the number of mango fruits by subtracting the number of apples and oranges from the total number of fruits\n    num_mangoes = n - num_apples - num_oranges\n    return num_mangoes", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/48": [{"task_id": "HumanEval/48", "solution": "def is_palindrome(text: str) -> bool:\n    \"\"\"\n    Checks if given string is a palindrome\n    \"\"\"\n    return text == text[::-1]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/37": [{"task_id": "HumanEval/37", "solution": "def sort_even(l: list) -> list:\n    evens = sorted([x for i, x in enumerate(l) if i % 2 == 0])\n    result = []\n    even_iter = iter(evens)\n    for i, x in enumerate(l):\n        if i % 2 == 0:\n            result.append(next(even_iter))\n        else:\n            result.append(x)\n    return result", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/23": [{"task_id": "HumanEval/23", "solution": "def strlen(string: str) -> int:\n    return len(string)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/63": [{"task_id": "HumanEval/63", "solution": "def fibfib(n: int) -> int:\n    if n == 0 or n == 1:\n        return 0\n    elif n == 2:\n        return 1\n    else:\n        a, b, c = 0, 0, 1\n        for _ in range(3, n + 1):\n            a, b, c = b, c, a + b + c\n        return c", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/40": [{"task_id": "HumanEval/40", "solution": "def triples_sum_to_zero(l: list) -> bool:\n    \"\"\"\n    triples_sum_to_zero takes a list of integers as an input.\n    it returns True if there are three distinct elements in the list that\n    sum to zero, and False otherwise.\n    \"\"\"\n    l.sort()  # sort the list in non-decreasing order\n    for i in range(len(l) - 2):  # iterate over the list, considering each element as a potential first element of a triple\n        if i > 0 and l[i] == l[i - 1]:  # skip duplicates to ensure distinct elements\n            continue\n        left, right = i + 1, len(l) - 1  # initialize two pointers, one at the next element and one at the end\n        while left < right:\n            s = l[i] + l[left] + l[right]  # calculate the sum of the current triple\n            if s < 0:  # if the sum is negative, move the left pointer to the right\n                left += 1\n            elif s > 0:  # if the sum is positive, move the right pointer to the left\n                right -= 1\n            else:  # if the sum is zero, return True\n                return True\n    return False  # if no triple is found, return False", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/34": [{"task_id": "HumanEval/34", "solution": "def unique(l: list) -> list:\n    \"\"\"Return sorted unique elements in a list\"\"\"\n    return sorted(set(l))", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/76": [{"task_id": "HumanEval/76", "solution": "import math\n\ndef is_simple_power(x, n):\n    \"\"\"\n    Returns True if x is a simple power of n, False otherwise.\n    \"\"\"\n    root = round(x ** (1.0 / n))\n    return root ** n == x", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[9, 3]], "plus_fail_tests": []}], "HumanEval/35": [{"task_id": "HumanEval/35", "solution": "def max_element(l: list):\n    return max(l)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/20": [{"task_id": "HumanEval/20", "solution": "from typing import List, Tuple\nimport itertools\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\"\n    From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    \"\"\"\n    # Generate all possible pairs of numbers\n    pairs = list(itertools.combinations(numbers, 2))\n    \n    # Find the pair with the minimum difference\n    closest_pair = min(pairs, key=lambda x: abs(x[0] - x[1]))\n    \n    # Return the pair in order (smaller number, larger number)\n    return tuple(sorted(closest_pair))", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/75": [{"task_id": "HumanEval/75", "solution": "def is_prime(n):\n    \"\"\"Helper function to check if a number is prime\"\"\"\n    if n <= 1:\n        return False\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef is_multiply_prime(a):\n    \"\"\"Returns True if the given number is the product of 3 prime numbers, False otherwise\"\"\"\n    if a < 100:  # optimization, since we know a is less than 100\n        for i in range(2, a):\n            if a % i == 0 and is_prime(i):\n                for j in range(i, a):\n                    if a // i % j == 0 and is_prime(j):\n                        for k in range(j, a):\n                            if a // (i * j) == k and is_prime(k):\n                                return True\n    return False", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/65": [{"task_id": "HumanEval/65", "solution": "def circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    \"\"\"\n    digits = [int(d) for d in str(x)]  # convert x to a list of digits\n    num_digits = len(digits)\n    effective_shift = shift % num_digits  # handle shift > num_digits\n    result = digits[-effective_shift:] + digits[:-effective_shift]  # circular shift\n    return \"\".join(map(str, result))  # convert back to a string", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[97, 8]], "plus_fail_tests": [[1234, 6]]}], "HumanEval/29": [{"task_id": "HumanEval/29", "solution": "from typing import List\n\ndef filter_by_prefix(strings: List[str], prefix: str) -> List[str]:\n    return [s for s in strings if s.startswith(prefix)]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/30": [{"task_id": "HumanEval/30", "solution": "def get_positive(l: list) -> list:\n    \"\"\"Return only positive numbers in the list.\"\"\"\n    return [x for x in l if x > 0]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/79": [{"task_id": "HumanEval/79", "solution": "def decimal_to_binary(decimal):\n    binary = bin(decimal)[2:]  # convert to binary and remove the '0b' prefix\n    return f\"db{binary}db\"  # add the extra 'db' characters", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/64": [{"task_id": "HumanEval/64", "solution": "def vowels_count(s):\n    s = s.lower()  # convert to lowercase for simplicity\n    count = 0\n    for c in s:\n        if c in 'aeiou':\n            count += 1\n        elif c == 'y' and s[-1] == c:\n            count += 1\n    return count", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [["aeiouyaeiouy"]]}], "HumanEval/73": [{"task_id": "HumanEval/73", "solution": "def smallest_change(arr):\n    \"\"\"\n    Given an array arr of integers, find the minimum number of elements that\n    need to be changed to make the array palindromic.\n\n    :param arr: list of integers\n    :return: minimum number of changes needed\n    \"\"\"\n    n = len(arr)\n    rev_arr = arr[::-1]  # reverse array\n    dp = [[0] * (n + 1) for _ in range(n + 1)]  # dp table\n\n    for i in range(1, n + 1):\n        for j in range(1, n + 1):\n            if arr[i - 1] == rev_arr[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1]\n            else:\n                dp[i][j] = 1 + min(dp[i - 1][j], dp[i][j - 1])\n\n    return dp[-1][-1]", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/50": [{"task_id": "HumanEval/50", "solution": "def decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) - 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/27": [{"task_id": "HumanEval/27", "solution": "def flip_case(string: str) -> str:\n    \"\"\" For a given string, flip lowercase characters to uppercase and uppercase to lowercase.\"\"\"\n    return \"\".join(c.swapcase() for c in string)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/43": [{"task_id": "HumanEval/43", "solution": "def pairs_sum_to_zero(l):\n    \"\"\"\n    pairs_sum_to_zero takes a list of integers as an input.\n    it returns True if there are two distinct elements in the list that\n    sum to zero, and False otherwise.\n    \"\"\"\n    seen = set()\n    for num in l:\n        if -num in seen:\n            return True\n        seen.add(num)\n    return False", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/58": [{"task_id": "HumanEval/58", "solution": "def common(l1: list, l2: list) -> list:\n    \"\"\"Return sorted unique common elements for two lists.\"\"\"\n    return sorted(set(l1) & set(l2))", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/47": [{"task_id": "HumanEval/47", "solution": "def median(l: list):\n    \"\"\"\n    Return the median of elements in the list l.\n    \"\"\"\n    l = sorted(l)\n    n = len(l)\n    if n % 2 == 1:\n        return l[n//2]\n    else:\n        return (l[n//2 - 1] + l[n//2]) / 2.0", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/77": [{"task_id": "HumanEval/77", "solution": "import math\n\ndef iscube(a):\n    '''\n    Returns True if the input integer is a cube of some integer number.\n    '''\n    return round(abs(a) ** (1. / 3)) ** 3 == abs(a)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/69": [{"task_id": "HumanEval/69", "solution": "def search(lst):\n    freq = {}\n    for num in lst:\n        if num > 0:\n            freq[num] = freq.get(num, 0) + 1\n\n    max_val = -1\n    for num, count in freq.items():\n        if count >= num:\n            max_val = max(max_val, num)\n\n    return max_val", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/71": [{"task_id": "HumanEval/71", "solution": "import math\n\ndef triangle_area(a, b, c):\n    '''\n    Given the lengths of the three sides of a triangle. Return the area of\n    the triangle rounded to 2 decimal points if the three sides form a valid triangle. \n    Otherwise return -1\n    Three sides make a valid triangle when the sum of any two sides is greater \n    than the third side.\n    Example:\n    triangle_area(3, 4, 5) == 6.00\n    triangle_area(1, 2, 10) == -1\n    '''\n    # Check if the three sides form a valid triangle\n    if a + b > c and a + c > b and b + c > a:\n        # Calculate the semi-perimeter\n        s = (a + b + c) / 2\n        # Calculate the area using Heron's formula\n        area = math.sqrt(s * (s - a) * (s - b) * (s - c))\n        # Return the area rounded to 2 decimal points\n        return round(area, 2)\n    else:\n        # Return -1 if the three sides do not form a valid triangle\n        return -1", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/80": [{"task_id": "HumanEval/80", "solution": "def is_happy(s):\n    \"\"\"\n    Returns True if the string is happy, False otherwise.\n    A string is happy if its length is at least 3 and every 3 consecutive letters are distinct.\n    \"\"\"\n    if len(s) < 3:\n        return False\n    for i in range(len(s) - 2):\n        if len(set(s[i:i+3])) != 3:\n            return False\n    return True", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/61": [{"task_id": "HumanEval/61", "solution": "def correct_bracketing(brackets: str) -> bool:\n    \"\"\"\n    Returns True if every opening bracket has a corresponding closing bracket, False otherwise.\n    \"\"\"\n    stack = []\n    for bracket in brackets:\n        if bracket == \"(\":\n            stack.append(bracket)\n        elif bracket == \")\":\n            if not stack:\n                return False\n            stack.pop()\n    return not stack", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/84": [{"task_id": "HumanEval/84", "solution": "def solve(N):\n    # Convert N to binary and remove the '0b' prefix\n    bin_N = bin(N)[2:]\n    \n    # Calculate the sum of the digits in binary\n    digit_sum = sum(int(digit) for digit in bin_N)\n    \n    # Convert the sum to binary and return it as a string\n    return bin(digit_sum)[2:]", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[10]]}], "HumanEval/72": [{"task_id": "HumanEval/72", "solution": "def will_it_fly(q, w):\n    return q == q[::-1] and sum(q) <= w", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/70": [{"task_id": "HumanEval/70", "solution": "def strange_sort_list(lst):\n    result = []\n    while lst:\n        result.append(min(lst))\n        lst.remove(min(lst))\n        if lst:\n            result.append(max(lst))\n            lst.remove(max(lst))\n    return result", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/82": [{"task_id": "HumanEval/82", "solution": "def prime_length(s):\n    \"\"\"\n    Returns True if the length of the input string is a prime number, False otherwise.\n    \"\"\"\n    def is_prime(n):\n        if n <= 1:\n            return False\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n\n    return is_prime(len(s))", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/68": [{"task_id": "HumanEval/68", "solution": "def pluck(arr):\n    evens = [(x, i) for i, x in enumerate(arr) if x % 2 == 0]\n    if not evens:\n        return []\n    return [min(evens)[0], min(evens)[1]]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/74": [{"task_id": "HumanEval/74", "solution": "def total_match(lst1, lst2):\n    total_chars1 = sum(len(s) for s in lst1)\n    total_chars2 = sum(len(s) for s in lst2)\n    if total_chars1 <= total_chars2:\n        return lst1\n    else:\n        return lst2", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/62": [{"task_id": "HumanEval/62", "solution": "def derivative(xs: list) -> list:\n    \"\"\"\n    xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n    Return derivative of this polynomial in the same form.\n    \"\"\"\n    return [i * x for i, x in enumerate(xs[1:], start=1)]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/86": [{"task_id": "HumanEval/86", "solution": "def anti_shuffle(s):\n    \"\"\"\n    Returns an ordered version of the input string, where each word is replaced\n    by a new word with characters in ascending order of ASCII value.\n    \"\"\"\n    return ' '.join(''.join(sorted(word)) for word in s.split())", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [["\n\n123 456\n789\n"]]}], "HumanEval/66": [{"task_id": "HumanEval/66", "solution": "def digitSum(s):\n    return sum(ord(c) for c in s if c.isupper())", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/87": [{"task_id": "HumanEval/87", "solution": "def get_row(lst, x):\n    \"\"\"\n    Given a 2D list and an integer x, return a list of coordinates (row, col) where x appears in the list.\n    Sort coordinates by row (asc) and then by col (desc) within each row.\n    \"\"\"\n    coords = [(i, j) for i, row in enumerate(lst) for j, elem in enumerate(row) if elem == x]\n    return sorted(coords, key=lambda x: (x[0], -x[1]))", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/81": [{"task_id": "HumanEval/81", "solution": "def numerical_letter_grade(grades):\n    \"\"\"\n    Convert a list of GPAs to a list of letter grades.\n\n    Args:\n        grades (list[float]): List of GPAs\n\n    Returns:\n        list[str]: List of letter grades\n    \"\"\"\n    letter_grades = []\n    for gpa in grades:\n        if gpa == 4.0:\n            letter_grades.append('A+')\n        elif gpa > 3.7:\n            letter_grades.append('A')\n        elif gpa > 3.3:\n            letter_grades.append('A-')\n        elif gpa > 3.0:\n            letter_grades.append('B+')\n        elif gpa > 2.7:\n            letter_grades.append('B')\n        elif gpa > 2.3:\n            letter_grades.append('B-')\n        elif gpa > 2.0:\n            letter_grades.append('C+')\n        elif gpa > 1.7:\n            letter_grades.append('C')\n        elif gpa > 1.3:\n            letter_grades.append('C-')\n        elif gpa > 1.0:\n            letter_grades.append('D+')\n        elif gpa > 0.7:\n            letter_grades.append('D')\n        elif gpa > 0.0:\n            letter_grades.append('D-')\n        else:\n            letter_grades.append('E')\n    return letter_grades", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/38": [{"task_id": "HumanEval/38", "solution": "def decode_cyclic(s: str):\n    \"\"\"\n    takes as input string encoded with encode_cyclic function. Returns decoded string.\n    \"\"\"\n    # split string to groups. Each of length 3.\n    groups = [s[(3 * i):min((3 * i + 3), len(s))] for i in range((len(s) + 2) // 3)]\n    # cycle elements in each group in reverse order. Unless group has fewer elements than 3.\n    groups = [(group[-1] + group[:-1]) if len(group) == 3 else group for group in groups]\n    return \"\".join(groups)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/85": [{"task_id": "HumanEval/85", "solution": "def add(lst):\n    return sum(x for i, x in enumerate(lst) if i % 2 != 0 and x % 2 == 0)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/99": [{"task_id": "HumanEval/99", "solution": "def closest_integer(value):\n    '''\n    Returns the closest integer to the given value, rounding away from zero if equidistant.\n    '''\n    num = float(value)\n    if num >= 0:\n        return round(num + 0.1) if num % 1 == 0.5 else round(num)\n    else:\n        return round(num - 0.1) if num % 1 == -0.5 else round(num)", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [["-6.5"]]}], "HumanEval/25": [{"task_id": "HumanEval/25", "solution": "from typing import List\n\ndef factorize(n: int) -> List[int]:\n    \"\"\"\n    Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appears in factorization.\n    Input number should be equal to the product of all factors\n    \"\"\"\n    i = 2\n    factors = []\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n            factors.append(i)\n    if n > 1:\n        factors.append(n)\n    return factors", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/91": [{"task_id": "HumanEval/91", "solution": "import re\n\ndef is_bored(S):\n    \"\"\"\n    Count the number of sentences that start with \"I\" (boredoms) in a given string.\n\n    Args:\n        S (str): The input string\n\n    Returns:\n        int: The number of boredoms\n    \"\"\"\n    sentences = re.split(r'[.!?]+', S)  # split into sentences using . , ! or ?\n    return sum(1 for s in sentences if s.lstrip().startswith('I') and s.strip())", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [["Is the sky blue?"]], "plus_fail_tests": [["In the morning, I like to have a cup of coffee to start my day off right. How about you?"]]}], "HumanEval/97": [{"task_id": "HumanEval/97", "solution": "def multiply(a, b):\n    return abs(a) % 10 * abs(b) % 10", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/78": [{"task_id": "HumanEval/78", "solution": "def hex_key(num):\n    \"\"\"\n    Counts the number of hexadecimal digits that are prime numbers.\n\n    Args:\n        num (str): A hexadecimal number as a string.\n\n    Returns:\n        int: The number of hexadecimal digits that are prime numbers.\n    \"\"\"\n    hex_to_dec = {'0': 0, '1': 1, '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9, 'A': 10, 'B': 11, 'C': 12, 'D': 13, 'E': 14, 'F': 15}\n    def is_prime(n):\n        if n <= 1:\n            return False\n        if n == 2:\n            return True\n        if n % 2 == 0:\n            return False\n        max_div = int(n**0.5) + 1\n        for i in range(3, max_div, 2):\n            if n % i == 0:\n                return False\n        return True\n\n    count = 0\n    for digit in num:\n        dec_digit = hex_to_dec[digit]\n        if is_prime(dec_digit):\n            count += 1\n    return count", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/88": [{"task_id": "HumanEval/88", "solution": "def sort_array(array):\n    \"\"\"\n    Given an array of non-negative integers, return a copy of the given array after sorting,\n    you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n    or sort it in descending order if the sum( first index value, last index value) is even.\n\n    Note:\n    * don't change the given array.\n\n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n    * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \"\"\"\n    if not array:  # if the array is empty, return an empty array\n        return []\n\n    first_last_sum = array[0] + array[-1]  # calculate the sum of first and last elements\n    sorted_array = sorted(array)  # create a sorted copy of the array\n\n    if first_last_sum % 2 == 0:  # if the sum is even, reverse the sorted array\n        sorted_array = sorted_array[::-1]\n\n    return sorted_array", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/95": [{"task_id": "HumanEval/95", "solution": "def check_dict_case(d):\n    \"\"\"\n    Given a dictionary, return True if all keys are strings in lower case or all keys are strings in upper case, else return False.\n    The function should return False if the given dictionary is empty.\n    \"\"\"\n    if not d:  # if the dictionary is empty, return False\n        return False\n    key_cases = [isinstance(k, str) and k.islower() for k in d] + [isinstance(k, str) and k.isupper() for k in d]\n    return all(key_cases) or all(~x for x in key_cases)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[{"p": "pineapple", "A": "banana", "B": "banana"}]], "plus_fail_tests": [[{"firstName": "John", "LASTNAME": "DOE", "Age": 35, "cItY": "new york", "Income": "$50,000"}]]}], "HumanEval/92": [{"task_id": "HumanEval/92", "solution": "def any_int(x, y, z):\n    if not all(isinstance(i, int) for i in (x, y, z)):\n        return False\n    return x == y + z or y == x + z or z == x + y", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/89": [{"task_id": "HumanEval/89", "solution": "def encrypt(s):\n    result = \"\"\n    for char in s:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            char_code = ord(char) - ascii_offset\n            char_code = (char_code + 2**2) % 26\n            result += chr(char_code + ascii_offset)\n        else:\n            result += char\n    return result", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/93": [{"task_id": "HumanEval/93", "solution": "def encode(message):\n    \"\"\"\n    Encodes a message by swapping case of all letters, and replacing\n    all vowels with the letter 2 positions ahead of it in the alphabet.\n    \"\"\"\n    vowels = 'aeiouAEIOU'\n    encoded_message = ''\n    for char in message:\n        if char.isalpha():  # only process letters\n            if char.islower():  # swap case if lowercase\n                encoded_char = char.upper()\n            else:\n                encoded_char = char.lower()\n            if char in vowels:  # replace vowels with 2 positions ahead\n                idx = ord(char.lower()) - 96  # 0-based index of 'a'\n                encoded_char = chr((idx + 2) % 26 + 65) if char.isupper() else chr((idx + 2) % 26 + 97)\n        else:\n            encoded_char = char  # leave non-letters unchanged\n        encoded_message += encoded_char\n    return encoded_message", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/90": [{"task_id": "HumanEval/90", "solution": "def next_smallest(lst):\n    \"\"\"\n    Returns the 2nd smallest element of the list, or None if there is no such element.\n    \"\"\"\n    if len(lst) < 2:\n        return None\n    sorted_lst = sorted(set(lst))  # remove duplicates and sort\n    if len(sorted_lst) < 2:\n        return None\n    return sorted_lst[1]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/102": [{"task_id": "HumanEval/102", "solution": "def choose_num(x, y):\n    \"\"\"\n    This function takes two positive numbers x and y and returns the \n    biggest even integer number that is in the range [x, y] inclusive. \n    If there's no such number, then the function returns -1.\n    \"\"\"\n    if x > y:  # swap x and y if x is greater than y\n        x, y = y, x\n    for i in range(y, x-1, -1):  # iterate from y to x in reverse order\n        if i % 2 == 0:  # check if the number is even\n            return i\n    return -1  # if no even number is found, return -1", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[13, 12]], "plus_fail_tests": [[100, 6]]}], "HumanEval/98": [{"task_id": "HumanEval/98", "solution": "def count_upper(s):\n    \"\"\"\n    Given a string s, count the number of uppercase vowels in even indices.\n    \n    For example:\n    count_upper('aBCdEf') returns 1\n    count_upper('abcdefg') returns 0\n    count_upper('dBBE') returns 0\n    \"\"\"\n    count = 0\n    for i, c in enumerate(s):\n        if i % 2 == 0 and c.isupper() and c in 'AEIOU':\n            count += 1\n    return count", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/107": [{"task_id": "HumanEval/107", "solution": "def even_odd_palindrome(n):\n    even_count = 0\n    odd_count = 0\n    for i in range(1, n+1):\n        if str(i) == str(i)[::-1]:  # check if i is a palindrome\n            if i % 2 == 0:  # check if i is even\n                even_count += 1\n            else:\n                odd_count += 1\n    return (even_count, odd_count)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/108": [{"task_id": "HumanEval/108", "solution": "def count_nums(arr):\n    return sum(1 for num in arr if sum(int(digit.lstrip('-')) for digit in str(abs(num))) > 0)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[-1, -2, 0]]], "plus_fail_tests": [[[-1, 0, 1]]]}], "HumanEval/109": [{"task_id": "HumanEval/109", "solution": "def move_one_ball(arr):\n    if not arr:  # if the array is empty, return True\n        return True\n\n    # Find the index of the minimum element in the array\n    min_idx = arr.index(min(arr))\n\n    # Check if the array can be sorted in non-decreasing order by rotating\n    return arr[min_idx:] + arr[:min_idx] == sorted(arr)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/112": [{"task_id": "HumanEval/112", "solution": "def reverse_delete(s, c):\n    \"\"\"\n    Delete all characters in s that are equal to any character in c, then check if the result string is a palindrome.\n\n    Args:\n        s (str): The original string\n        c (str): The characters to delete from s\n\n    Returns:\n        tuple: A tuple containing the result string and a boolean indicating whether the result string is a palindrome\n    \"\"\"\n    # Delete all characters in s that are equal to any character in c\n    result = ''.join([ch for ch in s if ch not in c])\n\n    # Check if the result string is a palindrome\n    is_palindrome = result == result[::-1]\n\n    return result, is_palindrome", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/115": [{"task_id": "HumanEval/115", "solution": "import math\n\ndef max_fill(grid, capacity):\n    \"\"\"\n    Returns the number of times the buckets need to be lowered to empty the wells.\n    \"\"\"\n    total_water = sum(sum(row) for row in grid)\n    return math.ceil(total_water / capacity)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[[1, 1, 1, 1], [1, 1, 1, 1]], 9]], "plus_fail_tests": []}], "HumanEval/104": [{"task_id": "HumanEval/104", "solution": "def unique_digits(x):\n    def has_no_evens(n):\n        return all(int(digit) % 2 != 0 for digit in str(n))\n\n    return sorted([num for num in x if has_no_evens(num)])", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/106": [{"task_id": "HumanEval/106", "solution": "def f(n):\n    result = []\n    for i in range(1, n+1):\n        if i % 2 == 0:  # i is even\n            factorial = 1\n            for j in range(1, i+1):\n                factorial *= j\n            result.append(factorial)\n        else:  # i is odd\n            result.append(sum(range(1, i+1)))\n    return result", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/101": [{"task_id": "HumanEval/101", "solution": "def words_string(s):\n    \"\"\"\n    Splits a string of words separated by commas or spaces into an array of words.\n\n    Args:\n        s (str): The input string\n\n    Returns:\n        list[str]: An array of words\n    \"\"\"\n    return [x.strip() for x in s.replace(\",\", \" \").split()]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/105": [{"task_id": "HumanEval/105", "solution": "def by_length(arr):\n    # Filter out numbers not between 1 and 9\n    arr = [x for x in arr if 1 <= x <= 9]\n    \n    # Sort the array\n    arr.sort()\n    \n    # Reverse the array\n    arr = arr[::-1]\n    \n    # Map each digit to its corresponding name\n    names = [\"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"]\n    arr = [names[x] for x in arr]\n    \n    return arr", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/111": [{"task_id": "HumanEval/111", "solution": "def histogram(test):\n    \"\"\"\n    Given a string representing a space separated lowercase letters, return a dictionary\n    of the letter with the most repetition and containing the corresponding count.\n    If several letters have the same occurrence, return all of them.\n    \"\"\"\n    # Split the input string into a list of individual letters\n    letters = test.split()\n    \n    # Create a dictionary to store the count of each letter\n    letter_counts = {}\n    for letter in letters:\n        if letter in letter_counts:\n            letter_counts[letter] += 1\n        else:\n            letter_counts[letter] = 1\n    \n    # Find the maximum count\n    max_count = max(letter_counts.values(), default=0)\n    \n    # Create a new dictionary with only the letters that have the max count\n    result = {letter: count for letter, count in letter_counts.items() if count == max_count}\n    \n    return result", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/113": [{"task_id": "HumanEval/113", "solution": "def odd_count(lst):\n    result = []\n    for i, s in enumerate(lst, start=1):\n        count = sum(c in '13579' for c in s)\n        result.append(f\"the number of odd elements {count}n the str{count}ng {count} of the {count}nput.\")\n    return result", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/110": [{"task_id": "HumanEval/110", "solution": "def exchange(lst1, lst2):\n    \"\"\"\n    Returns \"YES\" if it's possible to exchange elements between lst1 and lst2 to make all elements of lst1 even, \"NO\" otherwise.\n    \"\"\"\n    # Count the number of odd numbers in lst1\n    odd_count = sum(1 for x in lst1 if x % 2 != 0)\n    \n    # Count the number of even numbers in lst2\n    even_count = sum(1 for x in lst2 if x % 2 == 0)\n    \n    # If the number of odd numbers in lst1 is less than or equal to the number of even numbers in lst2, we can make all elements of lst1 even\n    if odd_count <= even_count:\n        return \"YES\"\n    else:\n        return \"NO\"", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/116": [{"task_id": "HumanEval/116", "solution": "def sort_array(arr):\n    return sorted(arr, key=lambda x: (bin(x).count('1'), x))", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/118": [{"task_id": "HumanEval/118", "solution": "def get_closest_vowel(word):\n    vowels = 'aeiouAEIOU'\n    for i in range(len(word) - 2, -1, -1):\n        if word[i] in vowels and word[i-1] not in vowels and word[i+1] not in vowels:\n            return word[i]\n    return \"\"", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [["ab"]], "plus_fail_tests": [["alb"]]}], "HumanEval/127": [{"task_id": "HumanEval/127", "solution": "def is_prime(n):\n    \"\"\"Helper function to check if a number is prime\"\"\"\n    if n <= 1:\n        return False\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef intersection(interval1, interval2):\n    \"\"\"Check if the length of the intersection of two intervals is a prime number\"\"\"\n    start1, end1 = interval1\n    start2, end2 = interval2\n\n    # Calculate the intersection of the two intervals\n    start_intersect = max(start1, start2)\n    end_intersect = min(end1, end2)\n\n    # If the intervals don't intersect, return \"NO\"\n    if start_intersect > end_intersect:\n        return \"NO\"\n\n    # Calculate the length of the intersection\n    intersect_len = end_intersect - start_intersect + 1\n\n    # Check if the length of the intersection is a prime number\n    if is_prime(intersect_len):\n        return \"YES\"\n    else:\n        return \"NO\"", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[-1, 1], [0, 4]]], "plus_fail_tests": [[[10, 20], [15, 25]]]}], "HumanEval/120": [{"task_id": "HumanEval/120", "solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n    \"\"\"\n    return sorted(arr, reverse=True)[:k]", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/114": [{"task_id": "HumanEval/114", "solution": "def minSubArraySum(nums):\n    \"\"\"\n    Given an array of integers nums, find the minimum sum of any non-empty sub-array\n    of nums.\n    \"\"\"\n    return min(sum(nums[i:j]) for i in range(len(nums)) for j in range(i+1, len(nums)+1))", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/126": [{"task_id": "HumanEval/126", "solution": "def is_sorted(lst):\n    return all(lst[i] <= lst[i+1] for i in range(len(lst)-1)) and all(lst.count(x) <= 1 for x in set(lst) if lst.count(x) > 1)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[1, 2, 2, 3, 3, 4]]], "plus_fail_tests": [[[1, 1, 2, 2, 3, 3, 4]]]}], "HumanEval/125": [{"task_id": "HumanEval/125", "solution": "def split_words(txt):\n    \"\"\"\n    Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n    should split on commas ',', if no commas exists you should return the number of lower-case letters with odd order in the\n    alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n    \"\"\"\n    if ' ' in txt:\n        return txt.split()\n    elif ',' in txt:\n        return [x.strip() for x in txt.split(',')]\n    else:\n        return sum((ord(c) - 97) % 2 == 1 for c in txt if c.islower())", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/117": [{"task_id": "HumanEval/117", "solution": "def select_words(s, n):\n    \"\"\"\n    Returns a list of all words from string s that contain exactly n consonants,\n    in the order they appear in the string s.\n    \"\"\"\n    # Define a set of consonants (both lowercase and uppercase)\n    consonants = set(\"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\")\n\n    # Split the input string into words\n    words = s.split()\n\n    # Initialize an empty list to store the result\n    result = []\n\n    # Iterate over each word in the input string\n    for word in words:\n        # Count the number of consonants in the current word\n        consonant_count = sum(1 for char in word if char in consonants)\n\n        # If the word has exactly n consonants, add it to the result list\n        if consonant_count == n:\n            result.append(word)\n\n    # Return the result list\n    return result", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/123": [{"task_id": "HumanEval/123", "solution": "def get_odd_collatz(n):\n    \"\"\"\n    Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n    \"\"\"\n    def collatz_sequence(n):\n        seq = [n]\n        while n != 1:\n            if n % 2 == 0:\n                n = n // 2\n            else:\n                n = 3 * n + 1\n            seq.append(n)\n        return seq\n\n    collatz_seq = collatz_sequence(n)\n    return sorted([x for x in collatz_seq if x % 2 != 0])", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/119": [{"task_id": "HumanEval/119", "solution": "def match_parens(lst):\n    def is_balanced(s):\n        stack = []\n        for c in s:\n            if c == '(':\n                stack.append(c)\n            elif c == ')':\n                if not stack:\n                    return False\n                stack.pop()\n        return not stack\n\n    a, b = lst\n    return 'Yes' if is_balanced(a + b) or is_balanced(b + a) else 'No'", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/122": [{"task_id": "HumanEval/122", "solution": "def add_elements(arr, k):\n    return sum(x for x in arr[:k] if len(str(x)) <= 2)", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[-99, -88, -77, -66, -55, -44, -33, -22, -11], 5]]}], "HumanEval/121": [{"task_id": "HumanEval/121", "solution": "def solution(lst):\n    return sum(x for i, x in enumerate(lst) if i % 2 == 0 and x % 2 != 0)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/129": [{"task_id": "HumanEval/129", "solution": "def minPath(grid, k):\n    N = len(grid)\n    flat_grid = [x for row in grid for x in row]\n    flat_grid.sort()\n    min_path = [float('inf')] * k\n\n    def dfs(i, j, path, k):\n        nonlocal min_path\n        if k == 0:\n            if path < min_path:\n                min_path = path[:]\n            return\n        for x, y in [(i-1, j), (i+1, j), (i, j-1), (i, j+1)]:\n            if 0 <= x < N and 0 <= y < N:\n                val = grid[x][y]\n                idx = flat_grid.index(val)\n                flat_grid.pop(idx)\n                dfs(x, y, path + [val], k-1)\n                flat_grid.insert(idx, val)\n\n    for i in range(N):\n        for j in range(N):\n            flat_grid.remove(grid[i][j])\n            dfs(i, j, [grid[i][j]], k-1)\n            flat_grid.insert(flat_grid.index((lambda x: x-1 if x > grid[i][j] else x)(min(flat_grid, key=lambda x: abs(x-grid[i][j])))), grid[i][j])\n\n    return min_path", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/124": [{"task_id": "HumanEval/124", "solution": "def valid_date(date):\n    \"\"\"\n    Validates a given date string and returns True if the date is valid, otherwise False.\n    \"\"\"\n    if not date:  # rule 1: date string is not empty\n        return False\n\n    parts = date.split('-')  # split the date string into month, day, year\n    if len(parts) != 3:  # check if the date string is in the correct format\n        return False\n\n    month, day, year = map(int, parts)  # convert month, day, year to integers\n\n    if not (1 <= month <= 12):  # rule 3: month should not be less than 1 or higher than 12\n        return False\n\n    if month in [1, 3, 5, 7, 8, 10, 12]:  # 31 days in these months\n        if not (1 <= day <= 31):\n            return False\n    elif month in [4, 6, 9, 11]:  # 30 days in these months\n        if not (1 <= day <= 30):\n            return False\n    elif month == 2:  # 29 days in February (leap year not considered)\n        if not (1 <= day <= 29):\n            return False\n\n    return True  # if all rules are satisfied, return True", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [["06-04-202"]]}], "HumanEval/128": [{"task_id": "HumanEval/128", "solution": "def prod_signs(arr):\n    if not arr:\n        return None\n    sign_prod = 1\n    mag_sum = 0\n    for num in arr:\n        if num > 0:\n            sign_prod *= 1\n        elif num < 0:\n            sign_prod *= -1\n        else:\n            sign_prod *= 0\n        mag_sum += abs(num)\n    return sign_prod * mag_sum", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/60": [{"task_id": "HumanEval/60", "solution": "def sum_to_n(n: int) -> int:\n    return sum(range(1, n + 1))", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/24": [{"task_id": "HumanEval/24", "solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\"\"\"\n    for i in range(n-1, 0, -1):\n        if n % i == 0:\n            return i\n    return 1  # return 1 if no other divisors are found (e.g. for prime numbers)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/132": [{"task_id": "HumanEval/132", "solution": "def is_nested(s):\n    stack = []\n    for c in s:\n        if c == '[':\n            stack.append(c)\n        elif c == ']':\n            if len(stack) == 0:\n                return False\n            elif len(stack) == 1:\n                stack.pop()\n            else:\n                stack.pop()\n                return True\n    return False", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [["[[]"]], "plus_fail_tests": [["[[][]["]]}], "HumanEval/141": [{"task_id": "HumanEval/141", "solution": "def file_name_check(file_name):\n    \"\"\"\n    Returns 'Yes' if the file name is valid, 'No' otherwise.\n    \"\"\"\n    # Check if there is exactly one dot\n    if file_name.count('.') != 1:\n        return 'No'\n\n    # Split the file name into two parts: before and after the dot\n    before_dot, after_dot = file_name.rsplit('.', 1)\n\n    # Check if the substring before the dot is not empty and starts with a latin alphabet letter\n    if not before_dot or not before_dot[0].isalpha():\n        return 'No'\n\n    # Check if the substring after the dot is one of the allowed extensions\n    if after_dot.lower() not in ['txt', 'exe', 'dll']:\n        return 'No'\n\n    # Count the number of digits in the file name\n    digit_count = sum(c.isdigit() for c in file_name)\n\n    # Check if there are not more than three digits\n    if digit_count > 3:\n        return 'No'\n\n    # If all conditions are met, return 'Yes'\n    return 'Yes'", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [["example.TXt"]]}], "HumanEval/131": [{"task_id": "HumanEval/131", "solution": "def digits(n):\n    product = 1\n    for digit in map(int, str(n)):\n        if digit % 2 == 0:  # even digit\n            return 0\n        product *= digit\n    return product", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[54]], "plus_fail_tests": [[182135]]}], "HumanEval/136": [{"task_id": "HumanEval/136", "solution": "def largest_smallest_integers(lst):\n    negatives = [x for x in lst if x < 0]\n    positives = [x for x in lst if x > 0]\n\n    if not negatives:\n        a = None\n    else:\n        a = max(negatives)\n\n    if not positives:\n        b = None\n    else:\n        b = min(positives)\n\n    return a, b", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/138": [{"task_id": "HumanEval/138", "solution": "def is_equal_to_sum_even(n):\n    \"\"\"\n    Evaluate whether the given number n can be written as the sum of exactly 4 positive even numbers\n    \"\"\"\n    if n % 2 != 0:  # if n is odd, it cannot be the sum of even numbers\n        return False\n    for a in range(0, n//2, 2):  # iterate over all possible even numbers\n        for b in range(a, n//2, 2):\n            for c in range(b, n//2, 2):\n                for d in range(c, n//2, 2):\n                    if a + b + c + d == n:\n                        return True\n    return False", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[6]], "plus_fail_tests": [[6]]}], "HumanEval/140": [{"task_id": "HumanEval/140", "solution": "import re\n\ndef fix_spaces(text):\n    \"\"\"\n    Given a string text, replace all spaces in it with underscores, \n    and if a string has more than 2 consecutive spaces, \n    then replace all consecutive spaces with -\n    \"\"\"\n    # Replace all spaces with underscores\n    text = text.replace(\" \", \"_\")\n    \n    # Use regular expression to find 3 or more consecutive underscores\n    # and replace them with a single hyphen\n    text = re.sub(r\"_+\", lambda x: \"-\" if len(x.group(0)) > 2 else \"_\", text)\n    \n    return text", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [["Yellow Yellow  Dirty  Fellow"]], "plus_fail_tests": [["  spaces  every  where  "]]}], "HumanEval/143": [{"task_id": "HumanEval/143", "solution": "def is_prime(n):\n    if n <= 1:\n        return False\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef words_in_sentence(sentence):\n    words = sentence.split()\n    result = [word for word in words if is_prime(len(word))]\n    return ' '.join(result)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/156": [{"task_id": "HumanEval/156", "solution": "def int_to_mini_roman(number):\n    \"\"\"\n    Given a positive integer, obtain its Roman numeral equivalent as a string,\n    and return it in lowercase.\n    Restrictions: 1 <= num <= 1000\n    \"\"\"\n    val = [\n        1000, 900, 500, 400,\n        100, 90, 50, 40,\n        10, 9, 5, 4,\n        1\n    ]\n    syb = [\n        \"m\", \"cm\", \"d\", \"cd\",\n        \"c\", \"xc\", \"l\", \"xl\",\n        \"x\", \"ix\", \"v\", \"iv\",\n        \"i\"\n    ]\n    roman_num = ''\n    i = 0\n    while  number > 0:\n        for _ in range(number // val[i]):\n            roman_num += syb[i]\n            number -= val[i]\n        i += 1\n    return roman_num", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/145": [{"task_id": "HumanEval/145", "solution": "def order_by_points(nums):\n    return sorted((x for x in nums), key=lambda x: (sum(int(d) for d in str(abs(x)).lstrip('-')), nums.index(x)))", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[-5, -12, 9, 15]]]}], "HumanEval/142": [{"task_id": "HumanEval/142", "solution": "def sum_squares(lst):\n    result = 0\n    for i, x in enumerate(lst):\n        if i % 3 == 0 and i % 4 != 0:\n            result += x ** 2\n        elif i % 4 == 0:\n            result += x ** 3\n        else:\n            result += x\n    return result", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[-1, -1, -1, -1, -1, -1, -1, -1, -1]]], "plus_fail_tests": []}], "HumanEval/134": [{"task_id": "HumanEval/134", "solution": "def check_if_last_char_is_a_letter(txt):\n    \"\"\"\n    Returns True if the last character of a given string is an alphabetical character\n    and is not a part of a word, and False otherwise.\n    \"\"\"\n    if not txt:  # empty string\n        return False\n    last_char = txt[-1]\n    if not last_char.isalpha():  # not an alphabetical character\n        return False\n    if txt.rstrip() != txt:  # trailing whitespace\n        return False\n    words = txt.split()\n    if len(words) > 1 and last_char in words[-2]:  # part of a previous word\n        return False\n    return True", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [["pUMPKIN PIE"]]}], "HumanEval/135": [{"task_id": "HumanEval/135", "solution": "def can_arrange(arr):\n    for i in range(len(arr) - 1, 0, -1):\n        if arr[i] <= arr[i-1]:\n            return i\n    return -1", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/155": [{"task_id": "HumanEval/155", "solution": "def even_odd_count(num):\n    \"\"\"\n    Given an integer, return a tuple that has the number of even and odd digits respectively.\n\n    Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\"\n    even_count = 0\n    odd_count = 0\n    for digit in str(abs(num)):  # convert to string to iterate over digits\n        if int(digit) % 2 == 0:\n            even_count += 1\n        else:\n            odd_count += 1\n    return even_count, odd_count", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/133": [{"task_id": "HumanEval/133", "solution": "import math\n\ndef sum_squares(lst):\n    return sum(math.ceil(x)**2 for x in lst)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/146": [{"task_id": "HumanEval/146", "solution": "def specialFilter(nums):\n    count = 0\n    for num in nums:\n        if num > 10 and (num % 10) % 2 != 0 and (abs(num) // 10**((len(str(abs(num)))-1))) % 2 != 0:\n            count += 1\n    return count", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/144": [{"task_id": "HumanEval/144", "solution": "def simplify(x, n):\n    \"\"\"\n    Returns True if x * n evaluates to a whole number, False otherwise.\n    x and n are string representations of fractions in the format <numerator>/<denominator>\n    \"\"\"\n    num_x, den_x = map(int, x.split('/'))\n    num_n, den_n = map(int, n.split('/'))\n    product_num = num_x * num_n\n    product_den = den_x * den_n\n    return product_num % product_den == 0", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/137": [{"task_id": "HumanEval/137", "solution": "def compare_one(a, b):\n    \"\"\"\n    Compare two numbers (int, float, or str) and return the larger one in its original type.\n    Return None if the values are equal.\n    \"\"\"\n    # Normalize string inputs to use . as decimal separator\n    if isinstance(a, str):\n        a = a.replace(',', '.')\n    if isinstance(b, str):\n        b = b.replace(',', '.')\n\n    # Convert both inputs to float for comparison\n    fa = float(a) if not isinstance(a, float) else a\n    fb = float(b) if not isinstance(b, float) else b\n\n    # Compare values\n    if fa > fb:\n        return a\n    elif fa < fb:\n        return b\n    else:\n        return None", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[1, "2,3"]], "plus_fail_tests": [["05,000", "1.0"]]}], "HumanEval/154": [{"task_id": "HumanEval/154", "solution": "def cycpattern_check(a, b):\n    \"\"\"\n    Returns True if the second word or any of its rotations is a substring in the first word\n    \"\"\"\n    # Generate all rotations of the second word\n    rotations = [b[i:] + b[:i] for i in range(len(b))]\n    \n    # Check if any of the rotations is a substring in the first word\n    return any(rot in a for rot in rotations)", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [["", ""]]}], "HumanEval/160": [{"task_id": "HumanEval/160", "solution": "def do_algebra(operators, operands):\n    \"\"\"\n    Evaluate an algebraic expression built from two lists: operators and operands.\n\n    Args:\n        operators (list[str]): List of basic algebra operations (+, -, *, //, **)\n        operands (list[int]): List of non-negative integers\n\n    Returns:\n        int: The result of the evaluated expression\n    \"\"\"\n    result = operands[0]\n    for i in range(len(operators)):\n        if operators[i] == '+':\n            result += operands[i+1]\n        elif operators[i] == '-':\n            result -= operands[i+1]\n        elif operators[i] == '*':\n            result *= operands[i+1]\n        elif operators[i] == '//':\n            result //= operands[i+1]\n        elif operators[i] == '**':\n            result **= operands[i+1]\n    return result", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[["+", "*", "-"], [2, 3, 4, 5]]], "plus_fail_tests": []}], "HumanEval/163": [{"task_id": "HumanEval/163", "solution": "def generate_integers(a, b):\n    \"\"\"\n    Given two positive integers a and b, return the even digits between a\n    and b, in ascending order.\n\n    For example:\n    generate_integers(2, 8) => [2, 4, 6, 8]\n    generate_integers(8, 2) => [2, 4, 6, 8]\n    generate_integers(10, 14) => []\n    \"\"\"\n    # Ensure a is the smaller number and b is the larger number\n    if a > b:\n        a, b = b, a\n\n    # Use a list comprehension to generate the even digits between a and b\n    evens = [i for i in range(a, b+1) if i % 2 == 0]\n\n    return evens", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/150": [{"task_id": "HumanEval/150", "solution": "def x_or_y(n, x, y):\n    \"\"\"\n    Returns x if n is a prime number, otherwise returns y.\n\n    :param n: The number to check for primality\n    :param x: The value to return if n is prime\n    :param y: The value to return if n is not prime\n    :return: x if n is prime, y otherwise\n    \"\"\"\n    def is_prime(num):\n        if num <= 1:\n            return False\n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    if is_prime(n):\n        return x\n    else:\n        return y", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/148": [{"task_id": "HumanEval/148", "solution": "def bf(planet1, planet2):\n    planets = [\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\n    if planet1 not in planets or planet2 not in planets:\n        return ()\n    idx1, idx2 = planets.index(planet1), planets.index(planet2)\n    if idx1 > idx2:\n        idx1, idx2 = idx2, idx1\n    return tuple(planets[idx1+1:idx2])", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/153": [{"task_id": "HumanEval/153", "solution": "def Strongest_Extension(class_name, extensions):\n    def extension_strength(ext):\n        cap = sum(1 for c in ext if c.isupper())\n        sm = sum(1 for c in ext if c.islower())\n        return cap - sm\n\n    strongest_ext = max(extensions, key=extension_strength)\n    return f\"{class_name}.{strongest_ext}\"", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/149": [{"task_id": "HumanEval/149", "solution": "def sorted_list_sum(lst):\n    return sorted([s for s in lst if len(s) % 2 == 0], key=lambda x: (len(x), x))", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/162": [{"task_id": "HumanEval/162", "solution": "import hashlib\n\ndef string_to_md5(text):\n    \"\"\"\n    Given a string 'text', return its md5 hash equivalent string.\n    If 'text' is an empty string, return None.\n    \"\"\"\n    if not text:\n        return None\n    md5_hash = hashlib.md5(text.encode('utf-8')).hexdigest()\n    return md5_hash", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/151": [{"task_id": "HumanEval/151", "solution": "def double_the_difference(lst):\n    return sum(i**2 for i in lst if isinstance(i, int) and i >= 0 and i % 2 != 0)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/157": [{"task_id": "HumanEval/157", "solution": "import math\n\ndef right_angle_triangle(a, b, c):\n    '''\n    Given the lengths of the three sides of a triangle. Return True if the three\n    sides form a right-angled triangle, False otherwise.\n    A right-angled triangle is a triangle in which one angle is right angle or \n    90 degree.\n    Example:\n    right_angle_triangle(3, 4, 5) == True\n    right_angle_triangle(1, 2, 3) == False\n    '''\n    # Sort the sides in non-decreasing order\n    a, b, c = sorted([a, b, c])\n    # Check if the square of the longest side is equal to the sum of the squares of the other two sides\n    return c**2 == a**2 + b**2", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/152": [{"task_id": "HumanEval/152", "solution": "def compare(game, guess):\n    return [abs(a - b) if a != b else 0 for a, b in zip(game, guess)]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/158": [{"task_id": "HumanEval/158", "solution": "def find_max(words):\n    max_unique_chars = 0\n    max_word = \"\"\n    for word in sorted(words):\n        unique_chars = len(set(word))\n        if unique_chars > max_unique_chars:\n            max_unique_chars = unique_chars\n            max_word = word\n    return max_word", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/159": [{"task_id": "HumanEval/159", "solution": "def eat(number, need, remaining):\n    \"\"\"\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    You should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \"\"\"\n    total_eaten = number + min(need, remaining)  # eat as many as you need or as many as are remaining\n    carrots_left = remaining - (total_eaten - number)  # calculate the remaining carrots\n    return [total_eaten, max(carrots_left, 0)]  # return the result, ensuring carrots_left is not negative", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/161": [{"task_id": "HumanEval/161", "solution": "def solve(s):\n    result = \"\"\n    has_letter = False\n    for c in s:\n        if c.isalpha():  # if c is a letter\n            has_letter = True\n            result += c.swapcase()  # reverse case\n        else:\n            result += c  # keep non-letters as is\n    if not has_letter:  # if no letters were found, reverse the string\n        result = result[::-1]\n    return result", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/36": [{"task_id": "HumanEval/36", "solution": "def fizz_buzz(n: int) -> int:\n    count = 0\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/103": [{"task_id": "HumanEval/103", "solution": "def rounded_avg(n, m):\n    if n > m:\n        return -1\n    avg = sum(range(n, m+1)) / (m - n + 1)\n    rounded_avg = round(avg)\n    return bin(rounded_avg)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/39": [{"task_id": "HumanEval/39", "solution": "def is_prime(n: int) -> bool:\n    \"\"\"\n    Helper function to check if a number is prime.\n    \"\"\"\n    if n <= 1:\n        return False\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef prime_fib(n: int) -> int:\n    \"\"\"\n    Returns the n-th number that is a Fibonacci number and it's also prime.\n    \"\"\"\n    a, b = 0, 1\n    count = 0\n    while True:\n        a, b = b, a + b\n        if is_prime(b):\n            count += 1\n        if count == n:\n            return b", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[12]]}], "HumanEval/55": [{"task_id": "HumanEval/55", "solution": "def fib(n: int) -> int:\n    \"\"\"Return n-th Fibonacci number.\"\"\"\n    if n <= 1:\n        return n\n    else:\n        return fib(n-1) + fib(n-2)", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[63]]}], "HumanEval/130": [{"task_id": "HumanEval/130", "solution": "def tri(n):\n    trib = [0] * (n + 1)\n    trib[0] = 1\n    trib[1] = 3\n    for i in range(2, n + 1):\n        if i % 2 == 0:\n            trib[i] = 1 + i // 2\n        else:\n            trib[i] = trib[i-1] + trib[i-2] + trib[i-1]\n    return trib", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[10]]}], "HumanEval/96": [{"task_id": "HumanEval/96", "solution": "def count_up_to(n):\n    def is_prime(num):\n        if num <= 1:\n            return False\n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    primes = []\n    num = 2\n    while len(primes) < n:\n        if is_prime(num) and num < n:\n            primes.append(num)\n        num += 1\n    return primes", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/100": [{"task_id": "HumanEval/100", "solution": "def make_a_pile(n):\n    \"\"\"\n    Given a positive integer n, returns a list of the number of stones in each level of a pile.\n    \"\"\"\n    pile = [n]\n    while len(pile) < n:\n        if n % 2 == 0:  # n is even\n            n += 2\n        else:  # n is odd\n            n += 2\n        pile.append(n)\n    return pile", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[2]]}], "HumanEval/147": [{"task_id": "HumanEval/147", "solution": "def get_max_triples(n):\n    a = [i * i - i + 1 for i in range(1, n + 1)]\n    count = 0\n    for i in range(len(a)):\n        for j in range(i + 1, len(a)):\n            for k in range(j + 1, len(a)):\n                if (a[i] + a[j] + a[k]) % 3 == 0:\n                    count += 1\n    return count", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/15": [{"task_id": "HumanEval/15", "solution": "def string_sequence(n: int) -> str:\n    return ' '.join(map(str, range(n + 1)))", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/94": [{"task_id": "HumanEval/94", "solution": "def skjkasdkd(lst):\n    def is_prime(n):\n        if n <= 1:\n            return False\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n\n    def sum_of_digits(n):\n        return sum(int(digit) for digit in str(n))\n\n    max_prime = max((x for x in lst if is_prime(x)), default=0)\n    return sum_of_digits(max_prime)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/83": [{"task_id": "HumanEval/83", "solution": "def starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\n    # Calculate the total count of n-digit numbers\n    total_count = 9 * (10 ** (n - 1))\n    \n    # Calculate the count of n-digit numbers that start with 1\n    starts_with_one = 10 ** (n - 1)\n    \n    # Calculate the count of n-digit numbers that end with 1\n    ends_with_one = total_count // 10\n    \n    # Remove the count of numbers that start and end with 1 (to avoid double counting)\n    starts_and_ends_with_one = 10 ** (n - 2) if n > 1 else 0\n    \n    # Return the count of numbers that start or end with 1\n    return starts_with_one + ends_with_one - starts_and_ends_with_one", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/139": [{"task_id": "HumanEval/139", "solution": "import math\n\ndef special_factorial(n):\n    result = 1\n    for i in range(1, n+1):\n        result *= math.factorial(i)\n    return result", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}]}}