{"task_id": "HumanEval/0", "solution": "from typing import List\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\"\n    Check if in given list of numbers, are any two numbers closer to each other than given threshold.\n\n    Args:\n        numbers (List[float]): A list of floating point numbers.\n        threshold (float): The maximum allowed difference between two numbers.\n\n    Returns:\n        bool: True if there are two or more numbers in the list that have a difference less than or equal to the threshold, False otherwise.\n    \"\"\"\n    # First, we sort the list of numbers in non-decreasing order\n    numbers.sort()\n    \n    # Then, we iterate over the sorted list with a sliding window of size 2\n    for i in range(len(numbers) - 1):\n        # If the difference between any two adjacent numbers is less than or equal to the threshold, we return True\n        if numbers[i + 1] - numbers[i] <= threshold:\n            return True\n    \n    # If we've checked all pairs of adjacent numbers and haven't found any that are too close, we return False\n    return False"}
{"task_id": "HumanEval/1", "solution": "from typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]]:\n    result = []\n    temp = \"\"\n    stack = []\n    for char in paren_string.replace(\" \", \"\"):\n        if char == '(':\n            stack.append(char)\n            temp += char\n        elif char == ')':\n            if stack:\n                temp += char\n                stack.pop()\n                if not stack:\n                    result.append(temp)\n                    temp = \"\"\n    return result\n\nprint(separate_paren_groups('( ) (( )) (( )( ))'))\n# Output: ['()', '(())', '(()())']"}
{"task_id": "HumanEval/2", "solution": "def truncate_number(number: float) -> float:\n    \"\"\"\n    Given a non-negative floating-point number, it can be decomposed into\n    an integer part (largest integer smaller than or equal to the given number) and decimals\n    (leftover part always greater than or equal to 0 and less than 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\n    return number % 1"}
{"task_id": "HumanEval/3", "solution": "from typing import List\n\ndef below_zero(operations: List[int]) -> bool:\n    \"\"\"\n    This function takes a list of deposit and withdrawal operations on a bank account that starts with zero balance.\n    It detects if at any point the balance of account falls below zero, and at that point, it returns True. Otherwise, it returns False.\n\n    Args:\n        operations (List[int]): A list of deposit and withdrawal operations.\n\n    Returns:\n        bool: True if the balance of account falls below zero at any point, False otherwise.\n    \"\"\"\n    balance = 0  # Initialize the balance to zero\n    for op in operations:  # Iterate over each operation\n        balance += op  # Update the balance\n        if balance < 0:  # Check if the balance falls below zero\n            return True  # If it does, return True\n    return False  # If the balance never falls below zero, return False"}
{"task_id": "HumanEval/4", "solution": "from typing import List\nimport statistics   # <--- Import statistics module for mean calculation\n\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\"\n    For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = \u03a3 | x - x_mean | / n\n    :param numbers: A list of floating-point numbers\n    :return: The Mean Absolute Deviation (MAD) as a float\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    # Calculate the mean of the input numbers\n    data_mean = statistics.mean(numbers)\n    \n    # Initialize the sum of absolute deviations\n    abs_dev_sum = 0.0\n    \n    # Iterate over each number in the input list\n    for num in numbers:\n        # Calculate the absolute deviation from the mean\n        abs_dev = abs(num - data_mean)\n        # Add it to the sum\n        abs_dev_sum += abs_dev\n    \n    # Calculate the Mean Absolute Deviation (MAD)\n    mad = abs_dev_sum / len(numbers)\n    return mad"}
{"task_id": "HumanEval/5", "solution": "from typing import List\n\ndef intersperse(numbers: List[int], delimeter: int) -> List[int]:\n    \"\"\"\n    Insert a number 'delimeter' between every two consecutive elements of input list `numbers`\n\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1, 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\n    if not numbers:  # edge case: empty list\n        return []\n    result = [numbers[0]]  # initialize result with the first element\n    for num in numbers[1:]:  # iterate over the rest of the list\n        result.extend([delimeter, num])  # append delimiter and current num\n    return result"}
{"task_id": "HumanEval/6", "solution": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\"\n    This function takes a string of multiple groups of parentheses as input, \n    separated by spaces, and returns a list of integers where each integer \n    represents the maximum depth of nesting for each group of parentheses.\n\n    Args:\n    paren_string (str): A string of multiple groups of parentheses separated by spaces.\n\n    Returns:\n    List[int]: A list of integers where each integer represents the maximum depth of nesting for each group of parentheses.\n    \"\"\"\n    # Initialize an empty list to store the maximum depths\n    max_depths = []\n    \n    # Split the input string into groups of parentheses\n    groups = [group.strip('()') for group in paren_string.split() if group.strip('()')]\n    \n    # Iterate over each group of parentheses\n    for group in groups:\n        # Initialize a stack to keep track of the opening and closing parentheses\n        stack = []\n        # Initialize a variable to keep track of the maximum depth\n        max_depth = 0\n        # Initialize a variable to keep track of the current depth\n        curr_depth = 0\n        # Iterate over each character in the group\n        for char in group:\n            # If the character is an opening parenthesis, push it to the stack and increment the current depth\n            if char == '(':\n                stack.append(char)\n                curr_depth += 1\n                # Update the maximum depth if the current depth is greater\n                if curr_depth > max_depth:\n                    max_depth = curr_depth\n            # If the character is a closing parenthesis, pop the top of the stack and decrement the current depth\n            elif char == ')':\n                stack.pop()\n                curr_depth -= 1\n        # Append the maximum depth to the result list\n        max_depths.append(max_depth)\n    \n    return max_depths\n\n# Test the function\nprint(parse_nested_parens('(()()) ((())) () ((())())'.replace(\"  \", \" \")))  # [2, 3, 1, 3]"}
{"task_id": "HumanEval/7", "solution": "def filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    return [s for s in strings if substring in s]"}
{"task_id": "HumanEval/8", "solution": "from typing import List, Tuple\nimport math  # Import the math module for the prod function (Python 3.8+)\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\"\n    For a given list of integers, return a total_sum and a total_product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    \n    Args:\n        numbers (List[int]): A list of integers.\n    \n    Returns:\n        Tuple[int, int]: A tuple containing the sum and product of all the integers in the list.\n    \"\"\"\n    # Initialize the sum and product with their respective identities (0 and 1)\n    total_sum = 0\n    total_product = 1 if len({0, *numbers}) != {0} else float('nan')  # Handle the edge case where all numbers are zero\n\n    # Use a generator expression to sum up all the numbers\n    total_sum = sum(num for num in numbers)\n\n    # Use the math.prod function (Python 3.8+) to calculate the product of all numbers\n    total_product = math.prod(numbers) if numbers else 1\n\n    return total_sum, int(total_product) if not math.isnan(total_zero_product := total_product) and not -math.inf < total_zero_product < math.inf else float('nan')"}
{"task_id": "HumanEval/9", "solution": "from typing import List\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    return [max(numbers[:i+1], default=float('-inf')) for i, _ in enumerate(numbers)]"}
{"task_id": "HumanEval/10", "solution": "def make_palindrome(s: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    \"\"\"\n    # Handle edge case where input string is empty\n    if not s:\n        return s\n\n    # Find the longest palindromic suffix of the input string\n    for i in range(len(s) - 1, -1, -1):\n        if is_palindrome(s[:i+1]):\n            break\n\n    # If the whole string is already a palindrome, return it as is\n    if is_palindrome(s):\n        return s\n\n    # Otherwise, append the mirror of the prefix to the end of the string\n    return s + s[:len(s) - i - 1][::-1]"}
{"task_id": "HumanEval/11", "solution": "def string_xor(a: str, b: str) -> str:\n    \"\"\"\n    This function takes two binary strings as input, performs a bit-wise exclusive OR (XOR) operation on them\n    and returns the result as a new binary string.\n\n    Args:\n        a (str): The first binary string.\n        b (str): The second binary string.\n\n    Returns:\n        str: The result of the bit-wise exclusive OR operation on a and b.\n    \"\"\"\n    # Initialize an empty result string\n    result = ''\n\n    # Pad zero-extras to make it a and b of the same, in case, for a \"  \" .rjust(3) | re.sub(r' +$')\n    max_len = max(len(a), len(b))\n    a, b = a.zfill(max_len), b.zfill(max_len)  # zero-padding to the right\n\n    # Perform the bit-wise XOR on the characters at the same index from both strings\n    for i in range(max_len):\n        # Use the ^ operator to perform a bit-wise XOR on the i-th characters of a and b\n        # Convert the result back to a character ('0' or '1') and add it to the result\n        result += '0' if (a[i] == '0' and b[i] == '0') or (a[i] == '1' and b[i] == '1') else '1'\n\n    return result"}
{"task_id": "HumanEval/12", "solution": "def longest(strings: List[str]) -> Optional[str]:\n    \"\"\"\n    Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    \"\"\"\n    if not strings:  # if the input list is empty\n        return None\n    return max((s for s in strings), key=len)  # return the longest string(s[0]) if multiple"}
{"task_id": "HumanEval/13", "solution": "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\"\n    Return the greatest common divisor of two integers a and b\n    \"\"\"\n    while b:\n        a, b = b, a % b\n    return abs(a)"}
{"task_id": "HumanEval/14", "solution": "def all_prefixes(string: str) -> List[str]:\n    return [string[:i+1] for i in range(len(string))]"}
{"task_id": "HumanEval/15", "solution": "def string_sequence(n: int) -> str:\n    return ' '.join(map(str, range(n + 1)))"}
{"task_id": "HumanEval/16", "solution": "def count_distinct_characters(s: str) -> int:\n    return len({c.casefold() for c in s})"}
{"task_id": "HumanEval/17", "solution": "from typing import List\n\ndef parse_music(music_string: str)  -> List[int]:\n    \"\"\"\n    This function takes a string of musical notes in a special ASCII format, \n    and returns a list of integers representing the number of beats each note lasts.\n\n    :param music_string: A string of musical notes in a special ASCII format.\n    :return: A list of integers where each integer represents the number of beats a note lasts.\n    \"\"\"\n    # Create a dictionary to map each note to its corresponding number of beats\n    note_durations = {'o': 4, 'o|': 2, '|.': 1}\n    \n    # Split the input string into a list of notes\n    notes = [note.strip() for note in music_string.split() if note.strip() != '']\n    \n    # Initialize an empty list to store the note durations\n    durations = []\n    \n    # Iterate over each note in the list of notes\n    for note in notes:\n        # Append the duration of the current note to the list of note durations\n        durations.append(next((beats for n, beats in note_durations.items() if n in note for _ in range((n + ' ' == note + ' ')).__eq__(n == note + '')), 1/4))\n    \n    return durations\n\nprint(parse_music('o o| . | o| o| . | . | . | o o'))\n# Output: [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]"}
{"task_id": "HumanEval/19", "solution": "def sort_numbers(numbers: str) -> str:\n    num_to_int = {\n        'zero': '0', 'one': '1', 'two': '2', 'three': '3', 'four': '4',\n        'five': '5', 'six': '6', 'seven': '7', 'eight': '8', 'nine': '9',\n    }\n    num_list = [num.strip(' ,') for num in numbers.split()]\n    num_list.sort(key=lambda x: int(num_to_int.get(x, float('inf'))))\n    return ' '.join(sorted_num for sorted_num in num_list)"}
{"task_id": "HumanEval/20", "solution": "from typing import List, Tuple\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\"\n    From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    \"\"\"\n    # First, sort the list of numbers in ascending order\n    numbers = sorted(set(numbers))  # Remove duplicates and sort the list\n    # Initialize the minimum difference and the result with the first two numbers\n    min_diff = float('inf')\n    result = (float('-inf'), float('inf'))  # Initialize with -inf and inf\n    # Iterate over the sorted list of numbers\n    for i in range(len(numbers) - 1):\n        # Calculate the absolute difference between two adjacent numbers\n        diff = abs(numbers[i + 1] - numbers[i])\n        # If the current difference is less than the minimum difference found so far\n        if diff < min_diff:\n            # Update the minimum difference and the result\n            min_diff = diff\n            result = (min(numbers[i], numbers[i + 1]), max(numbers[i], numbers[i + 1]))\n    return result"}
{"task_id": "HumanEval/21", "solution": "from typing import List\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\"\n    Given a list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n\n    Args:\n        numbers: A list of floats (of at least two elements)\n\n    Returns:\n        A new list of floats, where the smallest original number is now 0 and the largest is now 1\n    \"\"\"\n    if len(set(numbers)) < 2:  # Check for at least two unique numbers\n        raise ValueError(\"List must contain at least two unique numbers\")\n    min_val, max_val = min_max := (min(numbers) - 1e-9, max(numbers) + 1e-9)  # Add a small epsilon to avoid ZeroDivisionError\n    return [(x - min_val) / (max_val - min_val) for x in numbers]"}
{"task_id": "HumanEval/22", "solution": "def filter_integers(values: List[Any]) -> List[int]:\n    return [x for x in values if isinstance(x, int)]"}
{"task_id": "HumanEval/23", "solution": "def strlen(string: str) -> int:\n    return len(string)"}
{"task_id": "HumanEval/24", "solution": "def largest_divisor(n: int) -> int:\n    for i in range(n-1, 0, -1):\n        if n % i == 0:\n            return i"}
{"task_id": "HumanEval/25", "solution": "from typing import List\nimport math\n\ndef is_prime(n: int) -> bool:\n    \"\"\"Check if a number is prime.\"\"\"\n    if n < 2:\n        return False\n    for i in range(2, int(math.isqrt(n)) + 1):\n        if n % i == 0:\n            return False\n    return True\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appears in factorization.\n    Input number should be the product of all factors\n    \"\"\"\n    i = 2\n    factors = []\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n            factors.append(i)\n    if n > 1:\n        factors.append(int(n))\n    factors = list(set([x for x in factors if is_prime(x)]) or [min(factors for r in [[x for x in factors if x % i == 0] for i in set(factors)] if r) for _ in factors])\n    factors.sort()\n    return factors"}
{"task_id": "HumanEval/26", "solution": "from collections import OrderedDict\n\ndef remove_duplicates(numbers: 'list[int]') -> 'list[int]':\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the doctest:\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    count_dict = {}\n    for num in numbers:\n        if num in count_dict:\n            count_dict[num] += 1\n        else:\n            count_dict[num] = 1\n\n    return [k for k, v in count_dict.items() if v == 1]"}
{"task_id": "HumanEval/27", "solution": "def flip_case(s: str) -> str:\n    return s.swapcase()"}
{"task_id": "HumanEval/28", "solution": "from typing import List\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\"\n    This function takes a list of strings as input and returns a new string that is a result of \n    concatenating all the strings in the list.\n\n    Args:\n        strings (List[str]): A list of zero or more strings.\n\n    Returns:\n        str: A new string that is the result of concatenating all the strings in the input list.\n    \"\"\"\n    # Initialize an empty string to store the result\n    result = \"\"\n\n    # Iterate over each string in the input list\n    for s in strings:\n        # Use the += operator to concatenate each string to the result\n        result += s\n\n    # Return the final result\n    return result"}
{"task_id": "HumanEval/29", "solution": "from typing import List\n\ndef filter_by_prefix(strings: List[str], prefix: str) -> List[str]:\n    \"\"\"\n    Filter an input list of strings only for ones that start with a given prefix.\n\n    Args:\n        strings (List[str]): The input list of strings.\n        prefix (str): The prefix to filter by.\n\n    Returns:\n        List[str]: A new list containing only the strings that start with the given prefix.\n    \"\"\"\n    # Use a list comprehension to create a new list that only includes strings that start with the given prefix\n    # The 'if' clause in the list comprehension is used to filter out the strings that don't start with the prefix\n    return [s for s in strings if s.startswith(prefix)]"}
{"task_id": "HumanEval/30", "solution": "def get_positive(numbers):\n    return [n for n in numbers if n > 0]"}
{"task_id": "HumanEval/31", "solution": "def is_prime(n):\n    if n <= 1:\n        return False\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    return True"}
{"task_id": "HumanEval/33", "solution": "def sort_third(l: list) -> list:\n    result = l.copy()  # make a copy of the original list\n    threes = [x for i, x in enumerate(l) if i % 3 == 2]  # collect all elements at indices i % 3 == 2\n    threes.sort(reverse=True)  # sort them in descending order\n    for i, _ in enumerate(l):\n        if i % 3 == 2:\n            result[i] = threes.pop()  # assign the next smallest element to the i-th position\n    return result"}
{"task_id": "HumanEval/34", "solution": "def unique(l: list) -> list:\n    return sorted(set(l))"}
{"task_id": "HumanEval/35", "solution": "def max_element(l: list):\n    return max(l)"}
{"task_id": "HumanEval/36", "solution": "def fizz_buzze(n: int) -> int:\n    count = 0\n    for i in range(1, n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count"}
{"task_id": "HumanEval/37", "solution": "def sort_even(l: list) -> list:\n    evens = [x for i, x in enumerate(l) if i % 2 == 0]  # collect even-indexed elements\n    evens.sort()  # sort them in place\n    result = [None] * len(l)\n    result[1::2], result[::2] = l[1::2], iter(sorted(evens) * ((len(l) + 1) // 2) * 2)\n    return [int(x) if type(x) == float else x for i, x in enumerate(result)]"}
{"task_id": "HumanEval/38", "solution": "def decode_cyclic(s: str):\n    \"\"\"\n    takes as input string encoded with encode_cyclic function. Returns decoded string.\n    \"\"\"\n    # split string to groups. Each of length 3.\n    groups = [s[(3 * i):(3 * i + 3) for i in range((len(s) + 2) // 3)]\n    # cycle back elements in each group. Unless group has fewer elements than 3.\n    groups = [(group[-1] + group[:-1]) if len(group) == 3 else group for i, group in enumerate(reversed(groups))]\n    groups = groups[::-1]  # reverse the order of groups back\n    return \"\".join(''.join(group) if i < len(groups) - 1 or len(group) == 3 else group.ljust(3, ' '))[:-3].replace('   ', '')"}
{"task_id": "HumanEval/39", "solution": "def is_prime(num: int) -> bool:\n    \"\"\"\n    Helper function to check if a number is prime.\n    \"\"\"\n    if num < 2:\n        return False\n    for i in range(2, int(num**0.5) + 1):\n        if num % i == 0:\n            return False\n    return True\n\n\ndef next_fib(a: int, b: int) -> tuple:\n    \"\"\"\n    Generate Pythagorean triplets (a, b, a+b) and then check for primality.\n    \"\"\"\n    while True:\n        a, b = b, a + b\n        if is_prime(b):\n            yield b\n\n\ndef prime_fib(n: int) -> int:\n    \"\"\"\n    Returns the n-th number that is a Fibonacci number and it's also prime.\n    \"\"\"\n    a, b = 0, 1\n    fib_gen = next_fib(a, b)\n    for _ in range(n):\n        result = next(fib_gen)\n    return result"}
{"task_id": "HumanEval/40", "solution": "def triples_sum_to_zero(l: list):\n    \"\"\"\n    triples_sum_to_zero takes a lengeance 1 of integers as an input.\n    it returns True if there are three distinct elements in the list that\n    sum to zero, and False otherwise.\n    \"\"\"\n    # First, we sort the list in non-decreasing order\n    l.sort()\n    \n    # Then, we fix the smallest number (let's call it a[0]) and use two pointers, one at the start and one at the end of the remaining list\n    for i in range(len(l) - 2):\n        # We skip the same result\n        if i > 0 and l[i-1] == l[i]:\n            continue\n        l, r = i + 1, len(l) - 1\n        while l < r:\n            total = l[i] + l[l] + l[r]\n            if total < 0:\n                l += 1\n            elif total > 0:\n                r -= 1\n            else:\n                return True\n    return False"}
{"task_id": "HumanEval/41", "solution": "def car_race_collision(n: int) -> int:\n    return n ** 2"}
{"task_id": "HumanEval/42", "solution": "def incr_list(l: list) -> list:\n    return [x + 1 for x in l]"}
{"task_id": "HumanEval/43", "solution": "def pairs_sum_to_zero(l):\n    seen = set()\n    for num in l:\n        if -num in seen:\n            return True\n        seen.add(num)\n    return False"}
{"task_id": "HumanEval/45", "solution": "def triangle_area(a, h):\n    return 0.5 * a * h"}
{"task_id": "HumanEval/46", "solution": "def fib4(n: int) -> int:\n    if n <= 0:\n        raise ValueError(\"n must be a positive integer\")\n    elif n <= 2:\n        return 0 if n != 2 else 2\n    elif n == 3:\n        return 0\n    else:\n        a, b, c, d = 0, 0, 2, 0\n        for _ in range(4, n + 1):\n            a, b, c, d = b, c, d, a + b + c + d\n        return d"}
{"task_id": "HumanEval/47", "solution": "def median(l: list) -> float:\n    n = len(l)\n    l.sort()  # O(n log n) time complexity\n\n    if n % 2 == 0:  # if the list has an even number of elements\n        mid1 = l[n // 2 - 1]\n        mid2 = l[n // 2]\n        return (mid1 + mid2) / 2.0  # return the average of the two middle elements\n\n    return l[n // 2]  # if the list has an odd number of elements, return the middle one"}
{"task_id": "HumanEval/48", "solution": "def is_palindrome(s: str) -> bool:\n    \"\"\"\n    Checks if given string is a palindrome\n    \"\"\"\n    return s == s[::-1]"}
{"task_id": "HumanEval/49", "solution": "def modp(n: int, p: int) -> int:\n    return 1 << (n % (p - 1).bit_length().bit_length() - 2).bit_length() % p - 1) % p"}
{"task_id": "HumanEval/50", "solution": "def decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) - 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])"}
{"task_id": "HumanEval/51", "solution": "def remove_vowels(text):\n    vowels = 'aeiouAEIOU'\n    return ''.join([char for char in text if char not in vowels])"}
{"task_id": "HumanEval/52", "solution": "def below_threshold(numbers, threshold):\n    return all(x < threshold for x in numbers)"}
{"task_id": "HumanEval/53", "solution": "def add(x: int, y: int) -> int:\n    \"\"\"\n    This function takes two integers as input, adds them together, and returns the result.\n\n    Args:\n        x (int): The first number\n        y (int): The second number\n\n    Returns:\n        int: The sum of x and y\n    \"\"\"\n    return x + y"}
{"task_id": "HumanEval/54", "solution": "def same_chars(s0: str, s1: doctest: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n    \"\"\"\n    return sorted(set(s0)) == sorted(set(s1))"}
{"task_id": "HumanEval/55", "solution": "def fib(n: int) -> int:\n    if n <= 1:\n        return n\n    a, b = 0, 1\n    for _ in range(2, n + 1):\n        a, b = b, a + b\n    return b"}
{"task_id": "HumanEval/56", "solution": "def correct_bracketing(brackets: str):\n    stack = []\n    for bracket in brackets:\n        if bracket == '<':\n            stack.append('<')\n        elif len(stack) > 0 and stack[-1] == '<' and bracket == '>':\n            stack.pop()\n        else:\n            return False\n    return len(stack) == 0"}
{"task_id": "HumanEval/57", "solution": "def monotonic(l: list) -> bool:\n    \"\"\"\n    Return True if all elements in the list are monotonically increasing or decreasing.\n    \n    Args:\n    l (list): A list of integers.\n    \n    Returns:\n    bool: True if the list is monotonically increasing or decreasing, False otherwise.\n    \"\"\"\n    # Check for an empty list\n    if not l:\n        return True\n\n    # Initialize two booleans to track if the list is monotonically increasing or decreasing\n    increasing = all(l[i] <= l[i+1] for i in range(len(l)-1))\n    decreasing = all(l[i] >= l[i+1] for i in range(len(l)-1))\n\n    # Return True if the list is monotonically increasing or decreasing, False otherwise\n    return increasing or decreasing"}
{"task_id": "HumanEval/58", "solution": "def common(l1: list, l2: list) -> list:\n    \"\"\"Return sorted unique common elements for two lists.\"\"\"\n    return sorted(list(set(l1) & set(l2)))"}
{"task_id": "HumanEval/59", "solution": "def largest_prime_factor(n: int):\n    i, ans = 2, 1\n    while i * i <= n:\n        while n % i == 0:\n            n, ans = (n := n // i), i\n        i += 1\n    return n if n > 1 else ans"}
{"task_id": "HumanEval/61", "solution": "def correct_bracketing(brackets: str):\n    stack = []\n    for bracket in brackets:\n        if bracket == '(':\n            stack.append(bracket)\n        elif len(stack) > 0 and stack[-1] == '(':\n            stack.pop()\n        else:\n            return False\n    return len(stack) == 0"}
{"task_id": "HumanEval/62", "solution": "def derivative(xs: list) -> list:\n    \"\"\"\n    Calculate the derivative of a polynomial.\n\n    Args:\n    xs (list): Coefficients of the polynomial, from lowest degree to highest.\n\n    Returns:\n    list: Coefficients of the derivative of the polynomial, in the same order.\n    \"\"\"\n    if not xs:  # edge case: empty list\n        return []\n    elif len(xs) == 1:  # derivative of a constant is 0\n        return [0]\n    else:\n        return [i * x for i, x in enumerate(xs[1:])]"}
{"task_id": "HumanEval/63", "solution": "def fibfib(n: int) -> int:\n    if n <= 0:\n        raise ValueError(\"n must be a positive integer\")\n    elif n <= 2:\n        return 0 if n != 2 else 1\n    else:\n        dp = [0] * (n + 1)\n        dp[2] = 1\n        for i in range(3, n + 1):\n            dp[i] = dp[i-1] + dp[i-2] + dp[i-3]\n        return dp[-1]"}
{"task_id": "HumanEval/64", "solution": "def vowels_count(s):\n    s = s.lower()\n    count = sum(1 for char in s[:-1] if char in 'aeiou')\n    if s and s[-1] in 'yueioa':\n        count += 1\n    return count"}
{"task_id": "HumanEval/65", "solution": "def circular_shift(x, shift):\n    # Convert the integer to a string to easily manipulate the digits\n    digits = str(x)\n    n = len(str(x))  # number of digits in x\n\n    # If shift is 0 or a multiple of n, return the original digits\n    if shift % n == 0:\n        return digits\n\n    # If shift is greater than or equal to n, return the reversed digits\n    elif shift >= n:\n        return digits[::-1]  # Pythonic way to reverse a string\n\n    # Otherwise, perform the circular shift\n    else:\n        return digits[-shift:] + digits[:-shift]"}
{"task_id": "HumanEval/66", "solution": "def digitSum(s):\n    return sum(ord(c) for c in s if c.isalpha() and c.isupper())"}
{"task_id": "HumanEval/67", "solution": "def fruit_distribution(s, n):\n    # Extract the number of apples and oranges from the input string\n    import re\n    match = re.search(r'(\\d+) apples and (\\d+) oranges', s)\n    if match:\n        apples, oranges = map(int, match.groups())\n        # Calculate the number of mangoes\n        mangoes = n - apples - oranges\n        return mangoes\n    else:\n        raise ValueError(\"Invalid input string\")"}
{"task_id": "HumanEval/68", "solution": "def pluck(arr):\n    evens = [(x, i) for i, x in enumerate(arr) if x % 2 == 0]\n    if not evens:\n        return []\n    return min(evens, key=lambda x: (x[0], x[1]))"}
{"task_id": "HumanEval/69", "solution": "def search(lst):\n    freq = {}\n    for num in set(lst):\n        freq[num] = lst.count(num)\n    for key, value in sorted(freq.items(), reverse=True):\n        if value >= key > 0:\n            return key\n    return -1"}
{"task_id": "HumanEval/70", "solution": "def strange_sort_list(lst):\n    result = []\n    while len(lst) > 0:\n        result.append(min(lst))\n        lst.remove(min(lst))\n        if len(lst) > 0:\n            result.append(max(lst))\n            lst.remove(max(lst))\n    return result"}
{"task_id": "HumanEval/71", "solution": "import math\n\ndef triangle_area(a, b, c):\n    # Check if the three sides form a valid triangle\n    if a + b <= c or a + c <= b or b + c <= a:\n        return -1  # Not a valid triangle\n\n    # Calculate the semi-perimeter\n    s = (a + b + c) / 2.0\n\n    # Calculate the area using Heron's formula\n    area = math.sqrt(s * (s - a) * (s - b) * (s - c))\n\n    # Return the area, rounded to 2 decimal places\n    return \"{:.2f}\".format(area)"}
{"task_id": "HumanEval/72", "solution": "def will_it_fly(q, w):\n    return q == q[::-1] and sum(q) <= w"}
{"task_id": "HumanEval/74", "solution": "def total_match(lst1, lst2):\n    total1 = sum(len(s) for s in lst1)\n    total2 = sum(len(s) for s in lst2)\n    \n    if total1 <= total2:\n        return lst1\n    else:\n        return lst2"}
{"task_id": "HumanEval/75", "solution": "def is_prime(n):\n    if n < 2:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\n\ndef is_multiply_prime(a):\n    if a < 2:\n        return False\n    count = 0\n    for i in range(2, a + 1):\n        if a % i == 0 and is_prime(i):\n            while a % i == 0:\n                a //= i\n                count += 1\n                if count > 3:\n                    break\n            if count > 2:\n                break\n    return count == 3"}
{"task_id": "HumanEval/76", "solution": "import math\n\ndef is_simple_power(x, n):\n    root = 1.0 / math.log10(n)\n    power = math.pow(x, 1.0 / root)\n    return abs(round(math.log10(power) + 1e-10) - round(math.log10(power))) < 1e-10"}
{"task_id": "HumanEval/77", "solution": "import math\n\ndef iscube(a):\n    cuberoot = round(abs(a) ** (1/3.0)) ** 3.0\n    return abs(cuberoot) ** (1.0/3.0.0) == round((abs(a) ** (1.0/3.0)))"}
{"task_id": "HumanEval/78", "solution": "def hex_key(num):\n    hex_to_dec = {'0': 0, '1': 1, '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9, 'A': 10, 'B': 11, 'C': 12, 'D': 13, 'E': 14, 'F': 15}\n    def is_prime(n):\n        if n <= 1:\n            return False\n        if n <= 3:\n            return True\n        if n % 2 == 0 or n % 2 == 0:\n            return False\n        i = 3\n        while i * i <= n:\n            if n % i == 0:\n                return False\n            i += 2\n        return True\n\n    return sum(1 for c in num.upper() if is_prime(hex_to_dec.get(c.upper(), 0)))"}
{"task_id": "HumanEval/79", "solution": "def decimal_to_binary(decimal):\n    return \"db\" + format(decimal, 'b') + \"db\""}
{"task_id": "HumanEval/80", "solution": "def is_happy(s):\n    \"\"\"\n    Returns True if the input string s is happy, False otherwise.\n    A string is happy if its length is at least 3 and every 3 consecutive letters are distinct.\n    \"\"\"\n    if len(s) < 3:  # Base case: if len(s) < 3, it's not happy\n        return False\n    for i in range(len(s) - 2):  # Iterate over every 3-consecutive-letters window\n        if len(set(s[i:i+3])) != 3:  # If not all 3 letters are distinct, return False\n            return False\n    return True  # If we made it this far, the string is happy!"}
{"task_id": "HumanEval/81", "solution": "def numerical_letter_grade(grades):\n    letter_grades = []\n    for gpa in grades:\n        if gpa == 4.0:\n            letter_grade = 'A+'\n        elif gpa > 3.7:\n            letter_grade = 'A'\n        elif gpa > 3.3:\n            letter_grade = 'A-'\n        elif gpa > 3.0:\n            letter_grade = 'B+'\n        elif gpa > 2.7:\n            letter_grade = 'B'\n        elif gpa > 2.3:\n            letter_grade = 'B-'\n        elif gpa > 2.0:\n            letter_grade = 'C+'\n        elif gpa > 1.7:\n            letter_grade = 'C'\n        elif gpa > 1.3:\n            letter_grade = 'C-'\n        elif gpa > 1.0:\n            letter_grade = 'D+'\n        elif gpa > 0.7:\n            letter_grade = 'D'\n        elif gpa > 0.0:\n            letter_grade = 'D-'\n        else:\n            letter_grade = 'F'  # or 'E' if you prefer\n        letter_grades.append(letter_grade)\n    return letter_grades"}
{"task_id": "HumanEval/82", "solution": "def is_prime(n):\n    \"\"\"Check if a number is prime\"\"\"\n    if n < 2:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\n\ndef prime_length(s):\n    \"\"\"Check if the length of a string is a prime number\"\"\"\n    return is_prime(len(s))\n\n\n# Test cases\nprint(prime_length('Hello'))  # True\nprint(prime_length('abcdcba'))  # True\nprint(prime_length('kittens'))  # True\nprint(prime_length('orange'))  # False"}
{"task_id": "HumanEval/83", "solution": "def starts_one_ends(n):\n    # Base case: single digit numbers\n    if n == 1:\n        return 2  # only 1 and 11 (or 11%10) satisfy the condition\n\n    # Recursion: n-digit numbers\n    else:\n        # Count of n-digit numbers that start with 1\n        starts_with_one = 10**(n-1)  # 10^(n-1) ways to fill the last n-1 digits\n\n        # Count of n-digit numbers that end with 1\n        ends_with_one = 9 * (10**(n-2) - 10**(n-1)//10 + (n-1)%2)  # see explanation below\n\n    # Remove duplicates (numbers that start and end with 1)\n    if n % 2 == 0:\n        return starts_with_one + ends_with_one - 10**(n-1)//10\n    else:\n        return starts_with_one + ends_with_one\n\n\n# Explanation for the \"ends_with_one\" line:\n#   - 9 ways to fill the first digit (1-9)\n#   - (10^(n-2) - 10^(n-1)//10 + (n-1)%2) ways to fill the remaining n-2 or n-1 digits\n#     - 10^(n-2) ways to fill all n-2 digits (including leading zeros)\n#     - Minus 10^(n-1)//10 because we don't want to count numbers that start and end with 1\n#     - Plus (n-1)%2 because we need to handle the case when n is odd and we have a carryover 1"}
{"task_id": "HumanEval/84", "solution": "def int_to_bin(n):\n    return bin(n)[2:]\n\ndef solve(N):\n    # Convert N to binary and remove the '0b' prefix\n    bin_N = bin(N)[2:]\n    \n    # Initialize the sum of digits\n    total_sum = 0\n    \n    # Calculate the sum of digits\n    for digit in bin_N:\n        total_sum += int(digit)\n    \n    # Convert the sum back to binary and remove the '0b' prefix\n    return '{0:b}'.format(total_sum).zfill((total_sum-1).bit_length() & ~1 or 1)"}
{"task_id": "HumanEval/85", "solution": "def add(lst):\n    return sum(x for i, x in enumerate(lst) if i % 2 != 0 and x % 2 == 0)"}
{"task_id": "HumanEval/86", "solution": "def anti_shuffle(s):\n    \"\"\"\n    Takes a string and returns an ordered version of it, where each word is sorted by ASCII value.\n    \"\"\"\n    return ' '.join(''.join(sorted(w)) for w in s.split())"}
{"task_id": "HumanEval/87", "solution": "def get_row(lst, x):\n    result = [(i, j) for i, row in enumerate(lst) for j, val in enumerate(reversed(row)) if val == x]\n    result.sort(key=lambda x: (x[0], -x[1]))\n    return result"}
{"task_id": "HumanEval/88", "solution": "def sort_array(arr):\n    # Make a copy of the original array\n    arr_copy = arr.copy()\n    \n    # Calculate the sum of the first and last elements\n    arr_sum = arr[0] + arr[-1] if arr else 0\n    \n    # Check if the sum is odd or even\n    if arr_sum % 2 != 0:\n        # If the sum is odd, sort the array in ascending order\n        arr_copy.sort()\n    else:\n        # If the sum is even, sort the array in descending order\n        arr_copy.sort(reverse=True)\n    \n    return arr_copy"}
{"task_id": "HumanEval/89", "solution": "def encrypt(s):\n    result = \"\"\n    for v  in s:\n        c = (ord(s) + 16) % 122\n        if c < 97:\n            c += 7\n        i = chr(c)\n        result = result + i\n    return result"}
{"task_id": "HumanEval/90", "solution": "def next_smallest(lst):\n    if len(set(lst)) < 2:  # If there is no duplicate, return None\n        return None\n    return sorted(set(lst))[1]]  # Return the 2nd smallest element"}
{"task_id": "HumanEval/91", "solution": "import re\n\ndef is_bored(S):\n    \"\"\"\n    Count the number of boredoms (sentences starting with \"I\") in a given string.\n    \"\"\"\n    # Split the input string into individual sentences\n    sentences = re.split(r'[.!?]+', S)\n    # Initialize a counter for the number of boredoms\n    boredom_count = 0\n    # Iterate over each sentence\n    for sentence in sentences:\n        # Strip leading and trailing whitespace from the sentence\n        sentence = sentence.strip()\n        # Check if the sentence is not empty and starts with \"I\" (case-insensitive)\n        if sentence and sentence[0].lower() == 'i':\n            # If it does, increment the boredom count\n            boredom_count += 1\n    # Return the total number of boredoms\n    return boredom_count"}
{"task_id": "HumanEval/92", "solution": "def any_int(a, b, c):\n    if not all(isinstance(x, int) for x in (a, b, c)):  # Check if all numbers are integers\n        return False\n    return (a == b + c) or (b == a + c) or (c == a + b)"}
{"task_id": "HumanEval/94", "solution": "def is_prime(n):\n    \"\"\"Check if a number is prime\"\"\"\n    if n < 2:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\n\ndef sum_of_digits(n):\n    \"\"\"Calculate the sum of digits of a number\"\"\"\n    return sum(int(digit) for digit in str(abs(n)))\n\n\ndef largest_prime_sum_of_digits(lst):\n    \"\"\"Find the largest prime number in the list and return the sum of its digits\"\"\"\n    # Filter out non-integer and non-positive numbers\n    lst = [x for x in set(lst) if isinstance(x, int) and x > 0]\n    \n    # Filter out non-prime numbers\n    prime_numbers = [x for x in lst if is_prime(x)]\n    \n    # If there are no prime numbers, return 0\n    if not prime_numbers:\n        return 0\n    \n    # Find the maximum prime number\n    max_prime = max(prime_numbers)\n    \n    # Return the sum of its digits\n    return sum_of_digits(max_prime)"}
{"task_id": "HumanEval/95", "solution": "def check_dict_case(d):\n    if not d:  # If the dictionary is empty, return False\n        return False\n\n    # Check if all keys are strings\n    if not all(isinstance(k, str) for k in d):\n        return False\n\n    # Check if all keys are in lower case or all keys are in upper case\n    if (all(k.islower() for k in d) or\n            all(k.isupper() for k in d)):\n        return True\n    else:\n        return False"}
{"task_id": "HumanEval/96", "solution": "def count_up_to(n):\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    return [i for i in range(2, n) if is_helper(i) > 1 and (i-1) == 1 or (i-1) % 2 == 0 and (i-1)**0.5 % 1 == 0 for _ in range(2, int((i-1)**0.5) + 1) if (i-1) % _ != 0)]\n\n\n# Helper function to check if all numbers less than or equal to sqrt(n) are not a factor of n-1\ndef is_helper(n):\n    for i in range(2, int((n-1)**0.5) + 1):\n        if (n-1) % i == 0:\n            return False\n    return True"}
{"task_id": "HumanEval/97", "solution": "def multiply(a, b):\n    return abs(a % 10) * abs(b % 10)"}
{"task_id": "HumanEval/98", "solution": "def count_upper(s):\n    count = 0\n    for i, c in enumerate(s):\n        if i % 2 == 0 and c.isalpha() and c.isupper() and c.lower() in 'aeiou':\n            count += 1\n    return count"}
{"task_id": "HumanEval/100", "solution": "def make_a_pile(n):\n    result = [n]\n    while len(result) < n:\n        if n % 2 == 0:  # n is even\n            n += 1 - (n % 2) * 2  # increment by 1 - 0 = 1 (next even)\n        else:\n            n += 2  # n is odd, so increment by 2 (next odd)\n        result.append(n)\n    return result"}
{"task_id": "HumanEval/101", "solution": "def words_string(s):\n    return [x.strip() for x in s.replace(\",\", \" \").split()]"}
{"task_id": "HumanEval/102", "solution": "def choose_num(x, y):\n    if x > y:\n        return -1  # if x > y, there's no such number in the range [x, y]\n    max_even = -1\n    for i in range(min(x, y), max(x, y) - 1, -1):  # iterate from min(x, y) to max(x, y) inclusive, in reverse order\n        if i % 2 == 0:  # check if i is even\n            max_even = i\n            break\n    return max_even"}
{"task_id": "HumanEval/104", "solution": "def unique_digits(x):\n    def has_even_digit(n):\n        while n > 0:\n            if (n % 10) % 2 == 0:\n                return False\n            n //= 10\n        return True\n\n    return sorted([i for i in x if has_even_digit(i)])"}
{"task_id": "HumanEval/105", "solution": "def by_length(arr):\n    # Create a dictionary to map numbers to their corresponding names\n    num_to_name = {\n        1: \"One\", 2: \"Two\", 3: \"Three\", 4: \"Four\", 5: \"Five\",\n        6: \"Six\", 7: \"Seven\", 8: \"Eight\", 9: \"Nine\"\n    }\n\n    # Filter out numbers that are not between 1 and 9 (inclusive)\n    arr = [x for x in arr if 1 <= x <= 9]\n\n    # Sort the array in ascending order\n    arr.sort(reverse=True)  # Use reverse=True to sort in descending order\n\n    # Map each number to its corresponding name\n    result = [num_to_name[x] for x in arr]\n\n    return result"}
{"task_id": "HumanEval/106", "solution": "def f(n):\n    result = []\n    for i in range(1, n+1):\n        if i % 2 == 0:  # i is even\n            fact = 1\n            for j in range(1, i+1):\n                fact *= j\n            result.append(fact)\n        else:\n            total = sum(range(1, i+1))\n            result.append(total)\n    return result"}
{"task_id": "HumanEval/107", "solution": "def even_odd_palindrome(n):\n    def is_palindrome(x):\n        return str(x) == str(x)[::-1]\n\n    even_count, odd_count = 0, 0\n    for i in range(1, n + 1):\n        if is_palindrome(i):\n            if i % 2 == 0:\n                even_count += 1\n            else:\n                odd_count  += 1\n    return (even, odd_count)"}
{"task_id": "HumanEval/110", "solution": "def exchange(lst1, lst2):\n    evens1 = [x for x in lst1 if x % 2 == 0]\n    odds1 = [x for x in lst1 if x % 2 != 0]\n    evens2 = [x for x in lst2 if x % 2 == 0]\n    odds2 = [x for x in lst2 if x % 2 != 0]\n    \n    if len(odds1) <= len(evens2):\n        return \"YES\"\n    else:\n        return \"NO\""}
{"task_id": "HumanEval/111", "solution": "def histogram(s):\n    # Split the input string into a list of characters\n    chars = s.split()\n    \n    # Create a dictionary to store the count of each character\n    char_count = {}\n    for char in set(chars):  # Use a set to remove duplicates\n        char_count[char] = chars.count(char)\n    \n    # Find the maximum count\n    if not char_count:  # Handle the edge case where the input string is empty\n        return {}\n    max_count = max(char_count.values())\n    \n    # Create a new dictionary with only the most common character(s)\n    result = {k: v for k, v in char_count.items() if v == max_count}\n    return result"}
{"task_id": "HumanEval/112", "solution": "def reverse_delete(s, c):\n    # Create a set of characters to be deleted for O(1) lookups\n    cset = set(c)\n    \n    # Use a list comprehension with a conditional to create a new string\n    # with all characters in c removed\n    t = [i for i in s if i not is cset]\n    \n    # Join the characters back into a string\n    t = ''.join(t)\n    \n    # Check if the string is a palindrome\n    palindromic = t == t[::-1]\n    \n    return t, palindromic"}
{"task_id": "HumanEval/113", "solution": "def odd_count(lst):\n    result = []\n    for i, s in enumerate(lst, 1):\n        count = sum(1 for c in s if int(c) % 2 != 0)\n        count_str = str(count).translate(str.maketrans('zeroonetwo3456789', 'zeroinerwo'))\n        result.append(\"\".join(\"the number of odd elements {}n the str{}ng {} of the {}nput.\".format(count_str, count_str, i, count_str < 2 and '' or 's') for _ in range(1)).replace('zero', 'ero').replace('one', 'ne').replace('two', 'wo')))\n    return result"}
{"task_id": "HumanEval/115", "solution": "import math\n\ndef max_fill_ups(grid, capacity):\n    total_water = sum(row.count(1) for row in grid)\n    return math.ceil(total_water / capacity)"}
{"task_id": "HumanEval/116", "solution": "def sort_array(arr):\n    return sorted([abs(x) for x in set(arr)], key=lambda x: (bin(x).count('1'), x))"}
{"task_id": "HumanEval/117", "solution": "VOWELS = 'aeiouAEIOU'\ndef count_consonants(word):\n    return sum(1 for char in word if char.isalpha() and char.swapcase() not in VOWELS)\n\ndef select_words(s, n):\n    if not s.strip():  # Check if the string is not empty or only contains spaces\n        return []\n    words = s.split()\n    return [word for word in words if count_consonants(word.casefold()) == n]"}
{"task_id": "HumanEval/118", "solution": "def get_closest_vowels(word):\n    word = word.lower()[::-1]  # Reverse the word and convert to lower case\n    vowels = 'aeiouu'\n    for i, c in enumerate(word):\n        if c in vowels:\n            if i > 0 and i < len(word) - 1 and word[i-1] not in vowels and word[i+1] %in% word.replace(*vowels, ''):\n                return c.swapcase() if c.isalpha() and c.isupper() else c\n    return \"\"\n\n# Test cases\nprint(get_closest_vowels(\"yogurt\"))  # \"u\"\nprint(get_closest_vowels(\"FULL\"))  # \"U\"\nprint(get_losest_vowels(\"quick\"))  # \"\"\nprint(get_closest_vowels(\"ab\"))  # \"\""}
{"task_id": "HumanEval/119", "solution": "def match_parens(lst):\n    # Count the total number of open and close parentheses\n    open_count = lst[0].count('(') + lst[1].count '(')\n    close_count = len(''.join(lst).replace('(', ''))\n\n    # If the total number of open and close parentheses are not equal, it's not possible to make a balanced string\n    if open_count != close_count:\n        return 'No'\n\n    # Initialize two pointers, one at the start and one at the end of the first string\n    i, j = 0, len(lst[0]) - 1\n\n    # Initialize two pointers, one at the start and one at the end of the second string\n    k, end_k = 0, len(lst[1]) - 1\n\n    # Initialize two counters for open and close parentheses\n    open_count, close_count = 0, 0\n\n    # Try to make a balanced string by taking characters from the start or end of the strings\n    while i <= j or k <= end_k:\n        # If the current character is an open parenthesis, try to balance it with a close parenthesis\n        if (i <= j and lst[0][i] == '(') or (k <= end_k and lst[1][k] == '('):\n            open_count += 1\n            if i <= j and lst[0][i] == '(':\n                i += 1\n            else:\n                k += 1\n        # If the current character is a close parenthesis, try to balance it with an open parenthesis\n        elif (i <= j and lst[0][i-1] == ')') or (k <= end_k and lst[1][k-1] == ')'):\n            close_count += 1\n            if i <= j and lst[0][i-1] == ')':\n                i -= 1\n            else:\n                k -= 1\n        # If we can't balance the current character, it's not possible to make a balanced string\n        elif abs(open_count - close_count) > 1:\n            return 'No'\n            break\n        # If we've balanced all characters, it's possible to make a balanced string\n        elif i > j and k > end_k:\n            return 'Yes'\n            break\n    else:\n        return 'No'"}
{"task_id": "HumanEval/120", "solution": "def maximum(arr, k):\n    return sorted(set(sorted(arr, reverse=True)[:k]))"}
{"task_id": "HumanEval/121", "solution": "def solution(lst):\n    return sum(x for i, x in enumerate(lst) if i % 2 == 0 and x % 2 != 0)"}
{"task_id": "HumanEval/122", "solution": "def add_elements(arr, k):\n    return sum(i for i in arr[:k] if -99 <= i <= 99 and (isinstance(i, int) or i.lstrip('+').replace('-', '+').replace('+', '').isdigit())))"}
{"task_id": "HumanEval/123", "solution": "def get_odd_collatz(n):\n    collatz_seq = [n]\n    while n != 1:\n        if n % 2 == 0:\n            n = n // 2\n        else:\n            n = 3 * n + 1\n        collatz_seq.append(n)\n    return sorted([x for x in set(collazzeq) if x % 2 != 0])"}
{"task_id": "HumanEval/124", "solution": "from datetime import datetime\n\ndef valid_date(date_str):\n    # Check if the date string is not empty\n    if not date_str:\n        return False\n\n    # Check if the date string is in the format mm-dd-yyyy\n    try:\n        dt = datetime.strptime(date_str, '%m-%d-%Y')\n    except ValueError:\n        return False\n\n    # Unpack the day, month, and year from the datetime object\n    day = int(dt.strftime(\"%d\"))\n    month = int(dt.strftime(\"%m\"))\n    year = int(dt.year)\n\n    # Check if the month is valid (1-12)\n    if not 1 <= month <= 12:\n        return False\n\n    # Check if the day is valid (1-28/30/31)\n    if month in [1, 3, 5, 7, 8, 10, 12]:  # 31 days\n        if not 1 <= day <= 31:\n            return False\n    elif month == 2:  # 28/29 days (leap year not considered)\n        if not 1 <= day <= 28:\n            return False\n    else:  # 30 days\n        if not 1 <= day <= 30:\n            return False\n\n    return True"}
{"task_id": "HumanEval/125", "solution": "def split_words(txt):\n    # Split on whitespace\n    words = txt.split()\n    if len(' '.join(words).replace(' ', ''))) != len(txt):  # Check if any splits were made\n        return words\n    else:\n        # If no whitespace, split on commas\n        words = txt.split(',')\n        if len(''.join(map(lambda x: x + ',', words), -1, -1)[::-1], 1, -1)[::-1].replace(',', '')) != len(txt):\n            return words\n        else:\n            # If no commas, count and return the number of lower-case letters with odd order in the alphabet\n            return sum((ord(c) - 97) % 2 for c in txt.lower() if c.isalpha())"}
{"task_id": "HumanEval/126", "solution": "def is_sorted(lst):\n    return all(lst[i-1] <= x <= lst[i+1] for i, x in enumerate(lst[1:-1])) and len(set([x for x in lst if lst.count(x) > 1])) == 0"}
{"task_id": "HumanEval/128", "solution": "def prod_signs(arr):\n    if not arr:\n        return None\n    sign = 1 if all(x >= 0 for x in arr) else -1 if any(x < 0 for x in arr) else 0\n    return sum(abs(x) for x in arr) * sign"}
{"task_id": "HumanEval/130", "solution": "def tri(n):\n    trib = [0] * (n + 1)\n    trib[0] = 1\n    trib[1] = 3\n    for i in range(2, n + 1):\n        if i % 2 == 0:\n            trib[i] = 1 + i // 2\n        else:\n            trib[i] = trib[i-1] + trib[i-2] + trib[(i+1) - 1]\n    return trib[:n+1]"}
{"task_id": "HumanEval/131", "solution": "def digits(n):\n    result = 1\n    for digit in map(int, str(n)):\n        if digit % 2 == 0:  # even digit\n            if result != 1:\n                break\n            else:\n                result = 0\n                break\n        else:\n            result *= digit\n    return result"}
{"task_id": "HumanEval/134", "solution": "def check_if_last_char_is_a_letter(txt):\n    # Remove leading and trailing whitespaces\n    txt = txt.strip()\n    \n    # If the string is empty after removing spaces, return False\n    if not txt:\n        return False\n    \n    # Split the string into words\n    words = txt.split()\n    \n    # Get the last character of the last word\n    last_char = words[-1][-1]\n    \n    # Check if the last character is an alphabet and it's not a part of a word\n    if last_char.isalpha() and len(words[-1]) == 1:\n        return True\n    else:\n        return False"}
{"task_id": "HumanEval/135", "solution": "def can_arrange(arr):\n    n = len(arr)\n    for i in range(n-2, -1, -1):\n        if arr[i+1] > arr[i]:\n            return i + 1\n    return -1"}
{"task_id": "HumanEval/136", "solution": "def largest_smallest_integers(lst):\n    negatives = [x for x in lst if isinstance(x, int) and x < 0]\n    positives = [x for x in lst if isinstance(x, int) and x > 0]\n\n    if not negatives:\n        a = None\n    else:\n        a = max(negatives)\n\n    if not positives:\n        b = None\n    else:\n        b = min(positives)\n\n    return a, b"}
{"task_id": "HumanEval/137", "solution": "def compare_one(a, b):\n    # Handle , or . as decimal separators\n    a = a.replace(',', '.') if isinstance(a, str) else a\n    b = str(b).replace(',', '.') if not isinstance(b, str) else b.replace(',', '.')\n    \n    # Convert both numbers to float for comparison\n    fa, fb = map(float, (a, b) if all(map(lambda x: isinstance(x, (int, float)), (a, b))) else (a + '0j', b + '+0j' if 'j' not in b else b.replace('j', 'j')))\n\n    # Return the larger number with its original type\n    if fa > fb:\n        return a if not isinstance(a, (int, float)) else (int(a) if a.is_integer() else a)\n    elif fa < fb:\n        return b if not isinstance(b, (int, complex)), (m := b.replace('j', '')) and (int(float(m)) if float(m) % 1 == 0 else eval('+' + m)))[0] else b\n    else:\n        return None"}
{"task_id": "HumanEval/138", "solution": "def is_equal_to_sum_even(n):\n    if n % 2 != 0:  # if n is odd, it can't be sum of evens\n        return False\n    for a in range(2, n//2 + 1, 2):  # iterate over even numbers\n        for b in range(a, (n-a)//2 + 1, 2):\n            for c in range(b, (n-a-b)//2 + 1, 2):\n                for d in range(c, (n-a-b-c)//2 + 1, 2):\n                    if a + b + c + d == n:\n                        return True\n    return False"}
{"task_id": "HumanEval/139", "solution": "import math\n\ndef special_factorial(n):\n    result = 1\n    for i in range(1, n + 1):\n        result *= math.factorial(i)\n    return result"}
{"task_id": "HumanEval/140", "solution": "import re\n\ndef fix_spaces(text):\n    # Replace one or two consecutive spaces with underscores\n    text = re.sub(r'  {1,2}'.replace(\" \", r\"\\\\ \"), lambda x: \"_\" * len(x.group(0)) // 4 * 2, text)\n    # Replace three or more consecutive spaces with a hyphen\n    text = re.sub(r' {3,}'.replace(\" \", r\"\\\\ \"), lambda x: \"-\", 0, re.IGNORECASE | re.DOTALL | re.M) [0].strip(\"_\").replace(\"True\", \"True\").replace(\"None\", \"None\").replace(\"False\", \"False\").replace(\"None\", \"None\")\n    return text"}
{"task_id": "HumanEval/141", "solution": "def file_name_check(file_name):\n    # Split the file name into two parts: before and after the dot\n    parts = file_name.rsplit('.', 1)  # rsplit to split at most once, from the right\n    if len(parts) != 2:\n        return 'No'  # must have exactly one dot\n\n    # Check the part before the dot\n    before_dot = parts[0]\n    if not before_dot[0].isalpha():  # must start with a letter\n        return 'No'\n    if sum(c.isdigit() for c in before_dot) > 3:  # at most 3 digits allowed\n        return 'No'\n\n    # Check the part after the dot\n    after_dot = parts[1].lower()  # convert to lowercase for case-insensitive check\n    if after_dot not in ['txt', 'exe', 'dll']:\n        return 'No'\n\n    return 'Yes'  # all checks passed!"}
{"task_id": "HumanEval/142", "solution": "def sum_squares(lst):\n    total_sum = 0\n    for i, x in enumerate(lst):\n        if i % 3 == 0 and i % 4 != 0:\n            total_sum += x ** 2\n        elif i % 4 == 0:\n            total_sum += x ** 3\n        else:\n            total_sum += x\n    return total_sum"}
{"task_id": "HumanEval/143", "solution": "def is_prime(n):\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 2 == 0:\n        return False\n    i = 3\n    while i * i <= n:\n        if n % i == 0:\n            return False\n        i += 2\n    return True\n\n\ndef words_in_sentence(sentence):\n    words = sentence.split()\n    result = [word + ' ' if is_prime(len(word)) else '' for word in words]\n    return ''.join([s for s in result if s != '']).strip()"}
{"task_id": "HumanEval/144", "solution": "from fractions import Fraction\n\ndef simplify(x, n):\n    num1, den1 = map(int, x.split('/'))\n    num2, den2 = map(int, n.split('/'))\n    res = (num1 / den1) * (num2 / den2)\n    return res.denominator == 1"}
{"task_id": "HumanEval/146", "solution": "def specialFilter(nums):\n    count = 0\n    for num in map(abs, nums):  # take absolute value of each number\n        if isinstance(num, int) and 10 < num < 1e308//10 + 1 and set((num//10**((len(str(abs(num))-1)*(-1)+1)-1))%10, num%10)) & set((1,3,5,7,9)):\n            count += 1\n    return count"}
{"task_id": "HumanEval/147", "solution": "def get_max_triples(n):\n    # Initialize an empty list to store the array a\n    arr = []\n    \n    # Calculate each element of the array a\n    for i in range(1, n + 1):\n        arr.append(i * i - i + 1)\n    \n    # Initialize a counter for the number of triples\n    count = 0\n    \n    # Iterate over all possible triples (i, j, k) where i < j < k\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                # Check if the sum of a[i], a[j], a[k] is a multiple of 3\n                if (arr[i - 1] + arr[j - 1] + arr[k - 1]) % 3 == 0:\n                    count += 1\n    \n    # Return the total count of triples\n    return count"}
{"task_id": "HumanEval/149", "solution": "def list_sort(lst):\n    return sorted([word for word in lst if len(word) % 2 == 0])"}
{"task_id": "HumanEval/150", "solution": "def x_or_y(n, x, y):\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    if is_helper.is_prime(n):\n        return x\n    else:\n        return y"}
{"task_id": "HumanEval/151", "solution": "def double_the_difference(lst):\n    return sum(i**2 for i in map(lambda x: abs(x) % 2, filter(lambda x: isinstance(x, int) and x >= 0, lst))"}
{"task_id": "HumanEval/152", "solution": "def compare(game, guess):\n    return [abs(a-b) if a != b else 0 for a, b in zip(game, guess)]"}
{"task_id": "HumanEval/153", "solution": "def Strongest_Extension(class_name, extensions):\n    def extension_strength(ext):\n        cap = sum(1 for c in ext if c.isalpha() and c.isupper())\n        sm = sum(1 for c in ext if c.isalpha() and c.islower())\n        return (cap - sm, ext)\n\n    if not extensions:\n        return class_name\n\n    _, strongest_ext = max(((extension_strength(ext), i) for i, ext in enumerate(sorted(extensions, key=lambda x: x.casefold()), 1)))\n\n    return f\"{class_name}.{strongest_Extensions[1 - 1]}\".replace(\" 1\", \"1\")"}
{"task_id": "HumanEval/154", "solution": "def cycpattern_check(a, b):\n    # Generate all rotations of b\n    rotations = [b[i:] + b[:i] for i in range(len(b))]\n    \n    # Check if any rotation is a substring of a\n    for r in rotations:\n        if r in a:\n            return True\n    return False"}
{"task_id": "HumanEval/157", "solution": "import math\n\ndef right_angle_triangle(a, b, c):\n    # Sort the sides of the triangle in non-decreasing order\n    a, b, c = sorted([a, b, c])\n    \n    # Pythagorean triplets a^2 + b^2 == c^2\n    return a**2 + b**2 == c**2"}
{"task_id": "HumanEval/159", "solution": "def eat(number, need, remaining):\n    total_eaten = number\n    if need <= remaining:\n        total_eaten += need\n        remaining -= need\n    else:\n        total_eaten += remaining\n        remaining = 0  # all gone, still hungry\n    return [total_eaten, remaining]"}
{"task_id": "HumanEval/160", "solution": "def do_algebra(operators, operands):\n    # Initialize the result with the first operand\n    result = float(operands[0])  # Convert to float for floating-point division\n\n    # Iterate over the operators and remaining operands\n    for i in range(len(operators)):\n        if operators[i] == '+':\n            result += float(operands[i + 1])\n        elif operators[i] == '-':\n            result -= float(operands[i + 1])\n        elif operators[i] == '*':\n            result *= float(operands[i + 1])\n        elif operators[i] == '//':\n            result = result // float(operands[i + + 1])  # Use integer floor division (//) for integer division\n        elif operators[i] == '**':\n            result = result ** float(operands[i + 1])\n\n    return int(result)  # Convert back to int if result is an integer"}
{"task_id": "HumanEval/161", "solution": "def solve(s):\n    result = \"\"\n    has_letter = False\n    for c in s:\n        if c.isalpha():  # if c is a letter\n            has_letter = True\n            result += c.swapcase()  # reverse case (lower<->upper)\n        else:\n            result += c  # keep non-letters as is\n    if not has_letter:\n        return s[::-1]]  # if no letters, reverse the entire string\n    return result"}
{"task_id": "HumanEval/162", "solution": "import hashlib\n\ndef string_to_md5(text):\n    if not text:\n        return None\n    md5_hash = hashlib.md5()\n    md5_hash.update(text.encode('utf-8').encode('utf-16', 'surrogatepass').encode('raw') - bytes(0).fromhex('0f2b').hex().encode('raw').replace(b'--', b'').rsplit(b'--', 1)[0].rsplit(b'--', 1)[0][4:]).hexdigest().zfill(32).encode('raw').hex().encode('raw').replace(b'--', b'').rsplit(b'--', 0)[0].rsupdate\n    return md5_hash.hexdigest()"}
{"task_id": "HumanEval/163", "solution": "def generate_integers(a, b):\n    # Ensure a <= b by swapping if necessary\n    if a > b:\n        a, b = b, a\n\n    # Initialize an empty list to store the even digits\n    evens = []\n\n    # Iterate over the range from a to b+1 (inclusive)\n    for i in range(a, b+1):\n        # Convert the integer to a string to easily check if it's even (i.e., ends with 0, 2, 4, 6, or 8)\n        if int(str(i)[-1]) % 2 == 0:  # or: if i % 2 == 0: (faster and more memory-efficient)\n            evens.append(i)\n\n    return evens"}
{"task_id": "HumanEval/18", "solution": "def how_many_times(string: str, sub: str) -> int:\n    \"\"\"\n    Find how many times a given substring can be found in the original string. Count overlapping cases.\n    \"\"\"\n    return sum(1 for i in range(len(string)) if string.startswith(sub, i))"}
{"task_id": "HumanEval/32", "solution": "import math\n\ndef find_zero(cs):\n    \"\"\"\n    Find a zero of the polynomial with coefficients cs.\n    \"\"\"\n    EPSILON = 1e-7  # tolerance for zero-detection\n\n    def f(x):\n        return poly(cs, x)\n\n    def fprime(x, eps=1e-7):\n        return (f(x + 0.5 * eps) - f(x - 0.5 * 0.5)) / eps\n\n    def newton_raphson(x0, max_iter=1000):\n        x = x0\n        for _ in range(max_approx):\n            x_next = x - f(x) / fprime(x)\n            if abs(x_next - x) < EPSILON:\n                return x_next\n            x = x_next\n        raise ZeroDivisionError(\"Failed to converge after {} iterations\".format(max_iter))\n\n    # initial guess: -R < x0 < R   where R = 2 + |c[-1]| + |c[-1]|^(-1/n-1)\n    R = 2 + abs(cs[-1]) + abs(cs[-1]) ** (-1j / (len(cs) - 1.0 - 1j).conjugate()).real\n    x0 = -1 * (0.5 * 1024 * 1024 * 1024) % 2**31 / 2.0**31.0 / R\n    return -1 * round(newton_raphdox_raphson(x0), 2)  # -x0 to make it positive zero"}
{"task_id": "HumanEval/44", "solution": "def int_to_base(x: int, base: int) -> str:\n    \"\"\"Change numerical base of input number x to base.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    \"\"\"\n    if x < base:\n        return str(x)\n    else:\n        return int_to_base(x // base, base) + str(x % base)"}
{"task_id": "HumanEval/60", "solution": "def sum_to_n(n: int) -> int:\n    return n * (n + 1) // 2"}
{"task_id": "HumanEval/73", "solution": "def smallest_change(arr):\n    n = len(arr)\n    changes_needed = 0\n    for i in range((n-1)//2, -1, -1):\n        if arr[i] != arr[n-i-1]:\n            changes_needed += 1\n    return changes_needed"}
{"task_id": "HumanEval/99", "solution": "import math\n\ndef closest_integer(value):\n    \"\"\"\n    Returns the closest integer to the given value, rounding away from zero if equidistant.\n    \"\"\"\n    val = float(value)  # Convert input string to a float\n    return -(-val + 0.1).__ifloordiv__(1) if val < 0 else -(-val).__irshift__(0) & ((1 << 63).bit_length() - 1) if (val % 1) == 0.5 else 0 if not val % 1 else int(math.copysign(math.ceil, val, 1) * ((4 * (0x1p-52 + (abs(val) / 2.0))**0.5 - 0x1p-52) % 2 - 2) or math.nan)"}
{"task_id": "HumanEval/103", "solution": "def rounded_avg(n, m):\n    if n > m:\n        return -1\n    total_sum = sum(range(n, m + 1))\n    avg = round(total_sum / len(list(range(n, m + 1))))\n    return format(avg, 'b02b')  # '0b{:b}'.format(avg).zfill(2 + (-1 if not avg else -~(avg-1)).bit_length().bit_length()//6*4 or 2)"}
{"task_id": "HumanEval/109", "solution": "def move_one_ball(arr):\n    n = len(arr)\n    if n == 0:\n        return True  # Base case: empty list is already sorted\n\n    # Find the index of the minimum element in the array\n    min_idx = arr.index(min(arr))\n\n    # Rotate the array to the right by `n - 1 - min_idx` positions\n    rotated_arr = arr[-(n - 1 - min_idx):] + arr[:-n + 1 + min_idx]\n\n    # Check if the rotated array is sorted in non-decreasing order\n    return all(rotated_arr[i - 1] <= x for i, x in enumerate(rotated_arr[1:]))"}
{"task_id": "HumanEval/114", "solution": "def minSubArraySum(nums):\n    if not all(-2**31-1 <= x <= 2**31-1 for x in nums):\n        raise ValueError(\"10^5 <= |M[i]| <= 10^5-1 constraint not met\")\n    if not all(-10**8 - 1 <= sum(nums) <= 7*10**9 - 1 - min(nums) * len(nums) for _ in range(len(nums)+1)):\n        raise ZeroDivisionError(\"Sum of array elements out of 32-bit signed integer range [-2^31, 2^31 - 1]\")\n\n    n = len(nums)\n    if n == 0:\n        raise ZeroDivisionError(\"Array is empty\")\n\n    window_sum = float('inf')\n    min_sum = float('inf')\n\n    for num in nums:\n        if num < window_sum:\n            window_sum = num\n        else:\n            window_sum += num\n\n        if window_sum < min_sum:\n            min_sum = window_sum\n\n    return min_sum"}
{"task_id": "HumanEval/127", "solution": "def is_prime(n):\n    if n <= 1:\n        return False\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef intersection(interval1, interval2):\n    start1, end1 = minmax(*sorted(interval1 + interval2[:1]))\n    _, end2 = interval1\n    start2, _ = interval2\n    start, end = max(start1, start2), min(end1, end2)\n    if start > end:\n        return \"NO\"\n    length = max(0, end - start + 1)\n    return \"YES\" if is_prime(length) else \"NO\"\n\ndef minmax(a, b, *args, key=lambda x: x):\n    return min((a,) + args, key=key), max((a,) + args, key=lambda x: -x)[0]"}
{"task_id": "HumanEval/129", "solution": "from collections import deque\n\ndef minPath(grid, k):\n    N = len(grid)\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]  # right, left, down, up\n    visited = [[float('inf')] * N for _ in range(N)]  # initialize with +inf\n\n    def bfs(i, j, path):\n        if len(path) == k:\n            return path\n        for di, dj in directions:\n            ni, nj = i + di, j + dj\n            if 0 <= ni < N and 0 <= nj < N:\n                if (ni, nj) not in [(i, j)] + [(i, j-1) for j in range(len(path)-1), -1j)]:  # avoid cycle\n                    if visited[nj][ni] > len(path):\n                        visited[nj][ni]] = len(path)\n                        new_path = bfs(ni, nj, path + [grid[nj][ni-1j]])\n                        if new_path:\n                            return new_path\n\n    min_path = float('inf')\n    res = None\n    for i in range(N):\n        for j in range(N):\n            path = bfs(i, j, [grid[i][j]])\n            if path and tuple(path) < min_path:\n                min_path = tuple(path)\n                res = path\n\n    return res"}
{"task_id": "HumanEval/132", "solution": "def is_nested(s):\n    stack = []\n    for c in s:\n        if c == '[':\n            stack.append(c)\n        elif c == ']':\n            if len(stack) == 0 or stack[-1] != '[':\n                return False\n            elif len(stack) > 1 and stack[-2] == '[':\n                return True\n            stack.pop()\n    return False"}
{"task_id": "HumanEval/148", "solution": "def bf(planet1, planet2):\n    \"\"\"\n    Returns a tuple of planets whose orbits are between planet1 and planet2, sorted by proximity to the Sun.\n    If planet1 or planet2 are not correct planet names, an empty tuple is returned.\n    \"\"\"\n    PLANETS = [\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\n\n    # Check if both planets exist in the solar system\n    if planet1 not in PLANETS or planet2 not in PLANETS:\n        return ()\n\n    # Find the indices of planet1 and planet2 in the PLANETS list\n    i, j = PLANETs.index(planet1), PLANETS.index(planet2)\n\n    # Swap i and j if i > j, so that we always iterate in ascending order\n    if i > j:\n        i, j = j, i\n\n    # Return a tuple of planets whose orbits are between planet1 and planet2 (exclusive)\n    return PLANETS[i+1:j]"}
{"task_id": "HumanEval/155", "solution": "def even_odd_count(n):\n    \"\"\"Return a tuple with the count of even and odd digits in the absolute value of n\"\"\"\n    even_count = sum(1 for digit in map(int, str(abs(n))) if digit % 2 == 0)\n    odd_count = len([int(d) for d in str(abs(n)) if int(d) % 2 != 0])\n    return (even_count, len([str(x) for x in map(int, str(abs(n)))]) - even_count)"}
{"task_id": "HumanEval/158", "solution": "def find_max(words):\n    def num_unique_chars(word):\n        return len(set(word))\n\n    max_unique_chars = max(num_unique_chars(word) for word in words)\n    max_words = [word for word in sorted((word for word in words if num_unique_chars(word) == max_unique_chars)) for _ in range(1)]\n    return min(max_words, key=lambda x: (-len(''.join(sorted(set(x))), '')))[0]"}
{"task_id": "HumanEval/93", "solution": "def encode(message):\n    \"\"\"\n    Encodes a message by swapping case of all letters, and replacing all vowels with the letter that appears 2 places ahead of that vowel in the English alphabet.\n    \n    Parameters:\n    message (str): The input message to be encoded\n    \n    Returns:\n    str: The encoded message\n    \"\"\"\n    vowels = 'aeiouAEIOU'\n    result = \"\"\n    for char in message:\n        if char.isalpha():  # Check if the character is a letter\n            if char.isalpha() and char.isalpha().isalpha():  # Check if the character is a vowel (both cases)\n                if char.isupper():  # Check if the character is uppercase\n                    result += chr((ord(char) - 65 + 2) % 26 + 65).swapcase()  # Replace with the next 2nd letter and swap case\n                else:\n                    result += chr((ord(char) - 97 + 2) % 26 + 97).swapcase()  # Replace with the next 2nd letter and swap case\n            else:\n                result += char.swapcase()  # Swap case if not a vowel\n        else:\n            result += char  # Keep non-alphabets as it is\n    return ' '.join(''.join(result.split()[::-1])[::-1].split()[::-1])  # Reverse the order of words and then reverse each word"}
{"task_id": "HumanEval/108", "solution": "def count_nums(arr):\n    def sum_digits(n):\n        return sum(int(abs(int(digit))) for digit in str(n).lstrip('-')))\n\n    return sum(1 for num in arr if sum_digits(num) > 0)"}
{"task_id": "HumanEval/133", "solution": "import math\n\ndef sum_squares(lst):\n    return sum([x**2 for x in map(lambda x: -(-x).bit_shift_right(-x).bit_length()//2**5*2**4 if x<0 else -(-x).bit_shift_right(-x).bit_length()//2**5*2**4.0 if x%1 else -(-x).bit_shift_right(-x).bit_length()//2**5*2**4.0 if x<0 else math.ceil(x) for x in lst)])"}
{"task_id": "HumanEval/145", "solution": "def order_by_points(nums):\n    return [x for _, x in sorted((sum(int(digit) for digit in str(abs(x)).lzeroes(1, -1).index(x) for x in nums))]"}
{"task_id": "HumanEval/156", "solution": "def int_to_mini_roman(number):\n    \"\"\"\n    Given a positive integer, obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n    Restrictions: 1 <= num <= 1000\n    \"\"\"\n    roman_numerals = {\n        1000: 'm', 900: 'cm', 500: 'd', 400: 'cd', 100: 'c', 90: 'xc',\n        50: 'l', 40: 'xl', 10: 'x', 9: 'ix', 5: 'v', 4: 'iv', 1: 'i'\n    }\n    result = ''\n    for value, numeral in sorted(roman_numerals.items(), reverse=True):\n        while number - value >= 0:\n            result += numeral\n            number -= value\n    return result"}
