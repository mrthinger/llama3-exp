{"date": "2024-05-11 03:19", "hash": "84f4b93a1270b492e4c54d5212da7a5b", "eval": {"HumanEval/6": [{"task_id": "HumanEval/6", "solution": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\"\n    This function takes a string of multiple groups of nested parentheses as input, \n    separated by spaces, and returns a list of integers where each integer represents \n    the maximum level of nesting for each group.\n\n    Args:\n        paren_string (str): A string of multiple groups of nested parentheses separated by spaces.\n\n    Returns:\n        List[int]: A list of integers where each integer represents the maximum level of nesting for each group.\n    \"\"\"\n    \n    # Split the input string into a list of strings, each representing a group of parentheses\n    paren_groups = paren_string.split()\n    \n    # Initialize an empty list to store the maximum nesting levels for each group\n    max_nesting_levels = []\n    \n    # Iterate over each group of parentheses\n    for group in paren_groups:\n        # Initialize the current nesting level and the maximum nesting level to 0\n        curr_nesting_level = 0\n        max_nesting_level = 0\n        \n        # Initialize an empty stack to keep track of the opening parentheses\n        opening_parens = []\n        \n        # Iterate over each character in the current group\n        for char in group:\n            # If the character is an opening parenthesis, push it onto the stack and increment the current nesting level\n            if char == '(':\n                opening_parens.append(char)\n                curr_nesting_level += 1\n                # Update the maximum nesting level if the current level is greater\n                if curr_nesting_level > max_nesting_level:\n                    max_nesting_level = curr_nesting_level\n            # If the character is a closing parenthesis, pop the opening parenthesis from the stack and decrement the current nesting level\n            elif char == ')':\n                opening_parens.pop()\n                curr_nesting_level -= 1\n        \n        # Append the maximum nesting level for the current group to the result list\n        max_nesting_levels.append(max_nesting_level)\n    \n    # Return the list of maximum nesting levels\n    return max_nesting_levels", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/11": [{"task_id": "HumanEval/11", "solution": "from typing import List\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\"\n    Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    \"\"\"\n    result = \"\"\n    for i in range(max(len(a), len(b))):\n        bit_a = a[-1 - i % len(a)] if i < len(a) else '0'\n        bit_b = b[-1 - i % len(b)] if i < len(b) else '0'\n        if bit_a != bit_b:\n            result = '1' + result\n        else:\n            result = '0' + result\n    return result.lstrip('0') or '0'", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/10": [{"task_id": "HumanEval/10", "solution": "def make_palindrome(s: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\"\"\"\n    for i in range(len(s), -1, -1):\n        if is_palindrome(s[:i]):\n            return s + s[:len(s)-i-1][::-1]\n    return \"\"", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/5": [{"task_id": "HumanEval/5", "solution": "from typing import List\n\ndef intersperse(numbers: List[int], delimiter: int) -> List[int]:\n    \"\"\"\n    Insert a number 'delimiter' between every two consecutive elements of input list `numbers`\n\n    Args:\n        numbers (List[int]): The input list of integers\n        delimiter (int): The number to be inserted between every two consecutive elements\n\n    Returns:\n        List[int]: The modified list with the delimiter inserted\n    \"\"\"\n    if not numbers:  # If the input list is empty, return an empty list\n        return []\n    \n    result = [numbers[0]]  # Initialize the result list with the first element of the input list\n    for num in numbers[1:]:  # Iterate over the rest of the input list\n        result.extend([delimiter, num])  # Insert the delimiter and the current number into the result list\n    return result", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/8": [{"task_id": "HumanEval/8", "solution": "from typing import List, Tuple\nimport math\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\"\n    For a given list of integers, return a total_sum and a total_product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    \"\"\"\n    if not numbers:  # if the list is empty\n        return 0, 1  # return (0, 1) as per the problem statement\n    \n    total_sum = sum(numbers)  # calculate the sum of all numbers in the list\n    total_product = math.prod(numbers)  # calculate the product of all numbers in the list\n    return total_sum, total_product  # return the sum and product as a tuple", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/2": [{"task_id": "HumanEval/2", "solution": "def truncate_number(number: float) -> float:\n    \"\"\"\n    Return the decimal part of a given positive floating point number.\n\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\n    return number % 1", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/3": [{"task_id": "HumanEval/3", "solution": "from typing import List\n\ndef below_zero(operations: List[int]) -> bool:\n    \"\"\"\n    Detects if the balance of a bank account falls below zero at any point after a list of deposit and withdrawal operations.\n\n    Args:\n        operations (List[int]): A list of deposit (positive) and withdrawal (negative) operations.\n\n    Returns:\n        bool: True if the balance falls below zero at any point, False otherwise.\n    \"\"\"\n    balance = 0\n    for op in operations:\n        balance += op\n        if balance < 0:\n            return True\n    return False", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/7": [{"task_id": "HumanEval/7", "solution": "from typing import List\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    return [s for s in strings if substring in s]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/13": [{"task_id": "HumanEval/13", "solution": "def greatest_common_divisor(a: int, b: int) -> int:\n    while b:\n        a, b = b, a % b\n    return a", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/4": [{"task_id": "HumanEval/4", "solution": "from typing import List\nimport statistics\n\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\"\n    For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    \"\"\"\n    # Calculate the mean of the input numbers\n    mu = statistics.mean(numbers)\n    \n    # Calculate the absolute deviations from the mean\n    abs_devs = [abs(x - mu) for x in numbers]\n    \n    # Calculate the mean of the absolute deviations (MAD)\n    mad = sum(abs_devs) / len(abs_devs)\n    \n    return mad", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[2.109160016548039, 1.5, 2.0, 2.5, 3.0, 3.5, 4.0]]]}], "HumanEval/12": [{"task_id": "HumanEval/12", "solution": "from typing import List, Optional\n\ndef longest(strings: List[str]) -> Optional[str]:\n    if not strings:\n        return None\n    return max(strings, key=len)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/9": [{"task_id": "HumanEval/9", "solution": "from typing import List\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\"\n    From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    result = []\n    max_so_far = float('-inf')  # Initialize with negative infinity\n    for num in numbers:\n        max_so_far = max(max_so_far, num)\n        result.append(max_so_far)\n    return result", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/0": [{"task_id": "HumanEval/0", "solution": "from typing import List\nimport itertools\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\"\n    Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n\n    Args:\n        numbers (List[float]): A list of floating-point numbers.\n        threshold (float): The maximum allowed distance between two numbers.\n\n    Returns:\n        bool: True if any two numbers in the list are closer to each other than the threshold, False otherwise.\n    \"\"\"\n    for a, b in itertools.combinations(numbers, 2):\n        if abs(a - b) < threshold:\n            return True\n    return False", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/1": [{"task_id": "HumanEval/1", "solution": "from typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\"\n    This function takes a string of balanced parentheses as input, \n    separates them into groups, and returns a list of these groups.\n    \n    :param paren_string: A string containing multiple groups of balanced parentheses.\n    :return: A list of strings, where each string is a group of balanced parentheses.\n    \"\"\"\n    # Initialize an empty list to store the result\n    result = []\n    # Initialize an empty string to build the current group\n    current_group = \"\"\n    # Initialize a counter to keep track of the nesting level\n    nesting_level = 0\n    # Iterate over each character in the input string\n    for char in paren_string.replace(\" \", \"\"):\n        # If the character is an opening parenthesis, increment the nesting level\n        if char == \"(\":\n            nesting_level += 1\n        # If the character is a closing parenthesis, decrement the nesting level\n        elif char == \")\":\n            nesting_level -= 1\n        # Add the character to the current group\n        current_group += char\n        # If the nesting level is back to 0, it means we've found a complete group\n        if nesting_level == 0:\n            result.append(current_group)\n            current_group = \"\"\n    return result", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/14": [{"task_id": "HumanEval/14", "solution": "from typing import List\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\"\"\"\n    return [string[:i+1] for i in range(len(string))]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/19": [{"task_id": "HumanEval/19", "solution": "from typing import Dict, List\n\ndef sort_numbers(numbers: str) -> str:\n    \"\"\"\n    Sorts a space-delimited string of numberals from 'zero' to 'nine' in ascending order.\n\n    Args:\n    numbers (str): A space-delimited string of numberals.\n\n    Returns:\n    str: The sorted string of numberals.\n    \"\"\"\n    \n    # Create a dictionary to map numberals to their integer values\n    num_dict: Dict[str, int] = {\n        'zero': 0, 'one': 1, 'two': 2, 'three': 3, 'four': 4,\n        'five': 5, 'six': 6, 'seven': 7, 'eight': 8, 'nine': 9\n    }\n    \n    # Split the input string into a list of numberals\n    num_list: List[str] = numbers.split()\n    \n    # Sort the list of numberals based on their integer values\n    sorted_list: List[str] = [num for _, num in sorted((num_dict[num], num) for num in num_list)]\n    \n    # Join the sorted list into a string with spaces in between\n    sorted_str: str = ' '.join(sorted_list)\n    \n    return sorted_str", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/17": [{"task_id": "HumanEval/17", "solution": "from typing import List\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\"\n    Parse a music string in a special ASCII format and return a list of integers representing the number of beats each note lasts.\n\n    :param music_string: A string representing musical notes in a special ASCII format.\n    :return: A list of integers where each integer represents the number of beats a note lasts.\n    \"\"\"\n    note_legend = {'o': 4, 'o|': 2, '.|': 1}  # Create a legend to map notes to their corresponding beats\n    notes = [note.strip() for note in music_string.split()]  # Split the music string into individual notes and remove leading/trailing whitespaces\n    return [note_legend.get(note, 0) for note in notes]  # Use a list comprehension to map each note to its corresponding beats and return the result", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/16": [{"task_id": "HumanEval/16", "solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\"\n    Given a string, find out how many distinct characters (regardless of case) does it consist of\n\n    Args:\n        string (str): The input string\n\n    Returns:\n        int: The number of distinct characters in the string (ignoring case)\n    \"\"\"\n    # Convert the string to lowercase to ignore case differences\n    string = string.casefold()\n    \n    # Use a set to remove duplicates and count the number of unique characters\n    return len(set(string))", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/31": [{"task_id": "HumanEval/31", "solution": "def is_prime(n):\n    if n <= 1:\n        return False\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    return True", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/32": [{"task_id": "HumanEval/32", "solution": "import math\nimport cmath\nimport numpy as np\n\ndef find_zero(xs: list):\n    \"\"\"\n    Find a zero of a polynomial with coefficients xs.\n    \"\"\"\n    # Check if the length of xs is even and the last coefficient is non-zero\n    assert len(xs) % 2 == 0, \"Number of coefficients must be even\"\n    assert xs[-1] != 0, \"Leading coefficient must be non-zero\"\n\n    # Use the numpy.roots function to find all roots of the polynomial\n    roots = np.roots(xs)\n\n    # Select a real root (if it exists) or a complex root with zero imaginary part\n    for root in roots:\n        if isinstance(root, (int, float)) or (isinstance(root, complex) and root.imag == 0):\n            return -root.real  # Return the negative of the real part of the root\n\n    # If no real or complex root with zero imaginary part is found, raise a ValueError\n    raise ValueError(\"No real or complex root with zero imaginary part found\")", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/35": [{"task_id": "HumanEval/35", "solution": "def max_element(l: list) -> int:\n    \"\"\"Return maximum element in the list.\"\"\"\n    return max(l)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/26": [{"task_id": "HumanEval/26", "solution": "from typing import List\nfrom collections import OrderedDict\n\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    \"\"\"\n    seen = {}\n    result = []\n    for num in numbers:\n        if num not in seen:\n            seen[num] = 1\n            result.append(num)\n        elif seen[num] == 1:\n            result.remove(num)\n            del seen[num]\n    return result", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[1, 1, 1, 1, 2, 2, 2, 3, 3, 4, 4, 4]]]}], "HumanEval/34": [{"task_id": "HumanEval/34", "solution": "def unique(l: list) -> list:\n    \"\"\"Return sorted unique elements in a list\"\"\"\n    return sorted(set(l))", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/46": [{"task_id": "HumanEval/46", "solution": "def fib4(n: int) -> int:\n    if n <= 0:\n        raise ValueError(\"n must be a positive integer\")\n    elif n <= 2:\n        return 0 if n != 2 else 2\n    elif n == 3:\n        return 0\n\n    a, b, c, d = 0, 0, 2, 0  # base cases\n    for _ in range(4, n + 1):\n        a, b, c, d = b, c, d, a + b + c + d\n    return d", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[0]]}], "HumanEval/18": [{"task_id": "HumanEval/18", "solution": "def how_many_times(string: str, substring: str) -> int:\n    \"\"\"\n    Find how many times a given substring can be found in the original string. Count overlapping cases.\n\n    Args:\n        string (str): The original string to search in.\n        substring (str): The substring to search for.\n\n    Returns:\n        int: The number of times the substring is found in the string.\n    \"\"\"\n    return sum(1 for i in range(len(string)) if string.startswith(substring, i))", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/27": [{"task_id": "HumanEval/27", "solution": "def flip_case(s: str) -> str:\n    return s.swapcase()", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/21": [{"task_id": "HumanEval/21", "solution": "from typing import List\nimport math\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\"\n    Given a list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    \"\"\"\n    if len(set(numbers)) < 2:  # Check for duplicates\n        raise ValueError(\"List must have at least two unique elements\")\n    min_val = min(numbers)\n    max_val = max(numbers)\n    scale = lambda x: (x - min_val) / (max_val - min_val) if max_val != min_val else 0.0\n    return [scale(x) for x in numbers]", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[0.1, 0.5, 0.9, 0.3, 0.7]]]}], "HumanEval/33": [{"task_id": "HumanEval/33", "solution": "def sort_third(l: list) -> list:\n    \"\"\"\n    This function takes a list l and returns a list l' such that\n    l' is identical to l in the indices that are not divisible by three, while its values at the indices that are divisible by three are equal\n    to the values of the corresponding indices of l, but sorted.\n    \"\"\"\n    result = l.copy()  # Create a copy of the original list\n    thirds = [x for i, x in enumerate(l) if i % 3 == 0]  # Get all elements at indices divisible by 3\n    sorted_thirds = sorted((x for x in thirds))  # Sort these elements\n    for i, x in enumerate(l):\n        if i % 3 == 0:\n            result[i] = sorted_thirds.pop(0)  # Replace original value with sorted value\n    return result", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/28": [{"task_id": "HumanEval/28", "solution": "from typing import List\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\"\"\"\n    return ''.join(strings)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/22": [{"task_id": "HumanEval/22", "solution": "from typing import List, Any\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    return [x for x in values if isinstance(x, int)]", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[true, false, null, 0, -10, "test", [], {}, 3.14]]]}], "HumanEval/29": [{"task_id": "HumanEval/29", "solution": "from typing import List\n\ndef filter_by_prefix(strings: List[str], prefix: str) -> List[str]:\n    return [s for s in strings if s.startswith(prefix)]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/23": [{"task_id": "HumanEval/23", "solution": "def strlen(string: str) -> int:\n    return len(string)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/30": [{"task_id": "HumanEval/30", "solution": "def get_positive(numbers: list) -> list:\n    return [x for x in numbers if x > 0]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/20": [{"task_id": "HumanEval/20", "solution": "from typing import List, Tuple\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\"\n    From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    \"\"\"\n    # Sort the list of numbers in ascending order\n    numbers = sorted(set(numbers))  # Remove duplicates by converting to a set and then back to a list\n    # Initialize the minimum difference and the closest pair of numbers\n    min_diff = float('inf')  # Initialize with positive infinity\n    closest_pair = ()  # Initialize an empty tuple\n\n    # Iterate over the sorted list of numbers\n    for i in range(len(numbers) - 1):\n        # Calculate the difference between the current number and the next number\n        diff = numbers[i + 1] - numbers[i]\n        # If the difference is less than the minimum difference found so far, update the minimum difference and the closest pair\n        if diff < min_diff:\n            min_diff = diff\n            closest_pair = (numbers[i], numbers[i + 1])\n\n    return closest_pair", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[1.0, 2.0, 3.0, 4.0, 5.0, 2.0]]], "plus_fail_tests": [[[1.0, 1.2, 1.4, 1.4, 1.6, 1.8]]]}], "HumanEval/45": [{"task_id": "HumanEval/45", "solution": "def triangle_area(a, h):\n    \"\"\"Given length of a side and high return area for a triangle.\"\"\"\n    return 0.5 * a * h", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/55": [{"task_id": "HumanEval/55", "solution": "def fib(n: int) -> int:\n    if n <= 1:\n        return n\n    a, b = 0, 1\n    for _ in range(2, n + 1):\n        a, b = b, a + b\n    return b", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/41": [{"task_id": "HumanEval/41", "solution": "def car_race_collision(n: int) -> int:\n    \"\"\"\n    Calculate the number of collisions between two sets of n cars moving in opposite directions.\n\n    Args:\n        n (int): The number of cars in each set.\n\n    Returns:\n        int: The total number of collisions.\n    \"\"\"\n    return n * (2 * n - 1) // 2", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/65": [{"task_id": "HumanEval/65", "solution": "def circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    \"\"\"\n    digits = [int(d) for d in str(x)]  # convert x to a list of digits\n    n_digits = len(digits)\n    effective_shift = shift % n_digits  # handle shift > n_digits\n    result = digits[-effective_shift:] + digits[:-effective_shift]\n    return ''.join(map(str, result))  # convert back to a string", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[97, 8]], "plus_fail_tests": [[1234, 6]]}], "HumanEval/63": [{"task_id": "HumanEval/63", "solution": "def fibfib(n: int) -> int:\n    if n <= 1:\n        return 0\n    elif n == 2:\n        return 1\n    else:\n        a, b, c = 0, 0, 1\n        for _ in range(3, n + 1):\n            a, b, c = b, c, a + b + c\n        return c", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/48": [{"task_id": "HumanEval/48", "solution": "def is_palindrome(text: str) -> bool:\n    \"\"\"\n    Checks if given string is a palindrome\n    \"\"\"\n    return text == text[::-1]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/49": [{"task_id": "HumanEval/49", "solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware of numerics).\"\"\"\n    return pow(2, n, p) % p", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/44": [{"task_id": "HumanEval/44", "solution": "def change_base(x: int, base: int) -> str:\n    \"\"\"\n    Change the numerical base of input number x to base.\n    Return a string representation after the conversion.\n    Base numbers are less than 10.\n\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\"\n    if 2 > base or base > 10:\n        raise ValueError(\"Base must be between 2 and 10\")\n\n    digits = \"\"\n    while x:\n        x, r = divmod(x, base)\n        digits = str(r) + digits\n    return digits or '0'", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/60": [{"task_id": "HumanEval/60", "solution": "def sum_to_n(n: int) -> int:\n    return n * (n + 1) // 2", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/77": [{"task_id": "HumanEval/77", "solution": "import math\n\ndef iscube(a):\n    '''\n    Returns True if the input integer is a cube of some integer number, False otherwise.\n    '''\n    if a < 0:\n        a = -a  # make it non-negative to simplify the cube root calculation\n    cube_root = round(a ** (1/3.0))  # calculate the cube root and round to the nearest integer\n    return cube_root ** 3 == a  # check if cubing the result gives us back the original number", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/40": [{"task_id": "HumanEval/40", "solution": "def triples_sum_to_zero(nums: list) -> bool:\n    \"\"\"\n    Returns True if there are three distinct elements in the list that sum to zero, and False otherwise.\n    \"\"\"\n    nums = list(set(nums))  # remove duplicates\n    nums.sort()  # sort the list in non-decreasing order\n    n = len(nums)\n    for i in range(n - 2):\n        if i > 0 and nums[i] == nums[i - 1]:  # skip duplicates\n            continue\n        l, r = i + 1, n - 1\n        while l < r:\n            s = nums[i] + nums[l] + nums[r]\n            if s < 0:\n                l += 1\n            elif s > 0:\n                r -= 1\n            else:\n                return True  # found a triple summing to zero\n    return False", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[1, 3, -2, 1]]], "plus_fail_tests": []}], "HumanEval/75": [{"task_id": "HumanEval/75", "solution": "def is_prime(n):\n    if n <= 1:\n        return False\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef is_multiply_prime(a):\n    for i in range(2, a // 3 + 1):  # since a < 100, we only need to check up to a/3\n        if a % i == 0 and is_prime(i):\n            for j in range(i, (a // i) ** 0.5 + 1):\n                if a % (i * j) == 0 and is_prime(j):\n                    k = a // (i * j)\n                    if is_prime(k):\n                        return True\n    return False", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[30]], "plus_fail_tests": []}], "HumanEval/47": [{"task_id": "HumanEval/47", "solution": "def median(l: list) -> float:\n    \"\"\"\n    Return the median of elements in the list l.\n    \"\"\"\n    n = len(l)\n    sl = sorted(l)\n    if n % 2 == 1:\n        # If the length of the list is odd, return the middle element\n        return float(sl[n // 2])\n    else:\n        # If the length of the list is even, return the average of the two middle elements\n        return (sl[n // 2 - 1] + sl[n // 2]) / 2.0", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/76": [{"task_id": "HumanEval/76", "solution": "import math\n\ndef is_simple_power(x, n):\n    \"\"\"\n    Returns True if x is a simple power of n, False otherwise.\n    \"\"\"\n    if x <= 0:  # edge case: x must be positive\n        return False\n    power = math.log(x, n)  # take log base n of x\n    return power.is_integer()  # check if power is an integer", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[1, 1]], "plus_fail_tests": [[125, 5]]}], "HumanEval/64": [{"task_id": "HumanEval/64", "solution": "def vowels_count(s):\n    s = s.lower()  # Convert to lowercase for simplicity\n    count = sum(1 for c in s[:-1] if c in 'aeiou')  # Count vowels except 'y' at the end\n    if s and s[-1] == 'y':  # Check if the last char is 'y'\n        count += 1  # If it is, increment the count\n    return count", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/67": [{"task_id": "HumanEval/67", "solution": "def fruit_distribution(s, n):\n    \"\"\"\n    Returns the number of mango fruits in the basket given a string representation of apples and oranges and the total number of fruits.\n\n    :param s: a string representing the number of apples and oranges, e.g. \"5 apples and 6 oranges\"\n    :param n: an integer representing the total number of fruits in the basket\n    :return: an integer representing the number of mango fruits in the basket\n    \"\"\"\n    import re\n    apples, oranges = map(int, re.findall(r'\\b(\\d+)\\b', s))  # extract numbers from the string using regular expressions\n    return n - apples - oranges  # calculate the number of mangoes by subtracting apples and oranges from the total", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/79": [{"task_id": "HumanEval/79", "solution": "def decimal_to_binary(decimal):\n    binary_str = bin(decimal)[2:]  # convert to binary and remove '0b' prefix\n    return f\"db{binary_str}db\"", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/51": [{"task_id": "HumanEval/51", "solution": "def remove_vowels(text):\n    \"\"\"\n    Remove all vowels from a given string.\n    \"\"\"\n    vowels = 'aeiouAEIOU'\n    return ''.join([c for c in text if c not list(vowels)])", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/73": [{"task_id": "HumanEval/73", "solution": "def smallest_change(arr):\n    n = len(arr)\n    dp = [[float('inf')] * 26 for _ in range(n + 1)]\n    dp[0][0] = 0\n\n    for i in range(1, n + 1):\n        for j in range(26):\n            if i == 1 or arr[i - 1] - 97 == j:\n                dp[i][j] = dp[i - 1][j]\n            else:\n                dp[i][j] = 1 + min(dp[i - 1][:j] + dp[i - 1][j + 1:])\n    return min(dp[-1])", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/78": [{"task_id": "HumanEval/78", "solution": "def hex_key(num):\n    hex_to_dec = {'0': 0, '1': 1, '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9, 'A': 10, 'B': 11, 'C': 12, 'D': 13, 'E': 14, 'F': 15}\n    def is_prime(n):\n        if n <= 1:\n            return False\n        if n == 2:\n            return True\n        if n % 2 == 0:\n            return False\n        max_div = int(n**0.5) + 1\n        for i in range(3, min(4, max_div) + 1, 2):\n            if n % i == 0:\n                if i * i != n:\n                    return False\n        return True\n\n    count = 0\n    for char in num:\n        if is_prime(hex_to_dec[char]):\n            count += 1\n    return count", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [["123456789ABCDEF0"]], "plus_fail_tests": [["999999"]]}], "HumanEval/37": [{"task_id": "HumanEval/37", "solution": "def sort_even(l: list) -> list:\n    evens = sorted([x for i, x in enumerate(l) if i % 2 == 0])\n    result = [0] * len(l)\n    evens_index = 0\n    for i in range(len(l)):\n        if i % 2 == 0:\n            result[i] = evens[evens_index]\n            evens_index += 1\n        else:\n            result[i] = l[i]\n    return result", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/62": [{"task_id": "HumanEval/62", "solution": "def derivative(xs: list) -> list:\n    \"\"\"\n    Calculate the derivative of a polynomial represented by coefficients `xs`.\n\n    Args:\n        xs: Coefficients of the polynomial, where `xs[i]` is the coefficient of `x**i`.\n\n    Returns:\n        Coefficients of the derivative polynomial.\n    \"\"\"\n    return [i * coeff for i, coeff in enumerate(xs[1:], start=1)]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/72": [{"task_id": "HumanEval/72", "solution": "def will_it_fly(q, w):\n    \"\"\"\n    Returns True if the object q will fly, and False otherwise.\n    \"\"\"\n    # Check if the list is palindromic (balanced)\n    is_balanced = q == q[::-1]\n    \n    # Calculate the sum of the elements in the list\n    total_weight = sum(q)\n    \n    # Check if the total weight is less than or equal to the maximum possible weight\n    is_underweight = total_weight <= w\n    \n    # Return True if both conditions are met, False otherwise\n    return is_balanced and is_underweight", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/52": [{"task_id": "HumanEval/52", "solution": "def below_threshold(l: list, t: int) -> bool:\n    return all(x < t for x in l)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/61": [{"task_id": "HumanEval/61", "solution": "def correct_bracketing(brackets: str) -> bool:\n    \"\"\"\n    Returns True if every opening bracket has a corresponding closing bracket.\n    \"\"\"\n    stack = []\n    for c in brackets:\n        if c == '(':\n            stack.append(c)\n        elif c == ')':\n            if not stack:\n                return False\n            stack.pop()\n    return not bool(stack)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/43": [{"task_id": "HumanEval/43", "solution": "def pairs_sum_to_zero(l):\n    seen = set()\n    for num in l:\n        if -num in seen:\n            return True\n        seen.add(num)\n    return False", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/68": [{"task_id": "HumanEval/68", "solution": "def pluck(arr):\n    evens = [(x, i) for i, x in enumerate(arr) if x % 2 == 0]\n    if not evens:\n        return []\n    return [min(evens, key=lambda x: (x[0], x[1]))[0], evens.index(min(evens, key=lambda x: (x[0], x[1])))]", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[1, 2, 3]]], "plus_fail_tests": [[[7, 15, 12, 21, 8, 13]]]}], "HumanEval/58": [{"task_id": "HumanEval/58", "solution": "def common(l1: list, l2: list) -> list:\n    \"\"\"Return sorted unique common elements for two lists.\"\"\"\n    return sorted(set(l1) & set(l2))", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/38": [{"task_id": "HumanEval/38", "solution": "def decode_cyclic(s: str):\n    \"\"\"\n    takes as input string encoded with encode_cyclic function. Returns decoded string.\n    \"\"\"\n    # split string to groups. Each of length 3.\n    groups = [s[(3 * i):min((3 * i + 3), len(s))] for i in range((len(s) + 2) // 3)]\n    # uncycle elements in each group. Unless group has fewer elements than 3.\n    groups = [(group[-1:] + group[:-1]) if len(group) == 3 else group for group in groups]\n    return \"\".join(groups)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/42": [{"task_id": "HumanEval/42", "solution": "def incr_list(l: list) -> list:\n    return [x + 1 for x in l]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/66": [{"task_id": "HumanEval/66", "solution": "def digitSum(s):\n    return sum(ord(c) for c in s if c.isalpha() and c.isupper())", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/69": [{"task_id": "HumanEval/69", "solution": "def search(lst):\n    from collections import Counter\n    counter = Counter(lst)\n    for num, freq in sorted(counter.items(), reverse=True):\n        if freq >= num > 0:\n            return num\n    return -1", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/56": [{"task_id": "HumanEval/56", "solution": "def correct_bracketing(brackets: str) -> bool:\n    \"\"\"\n    Returns True if every opening bracket has a corresponding closing bracket.\n    \"\"\"\n    stack = []\n    for bracket in brackets:\n        if bracket == \"<\":\n            stack.append(bracket)\n        elif bracket == \">\":\n            if not stack:\n                return False\n            stack.pop()\n    return not bool(stack)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/53": [{"task_id": "HumanEval/53", "solution": "def add(x: int, y: int) -> int:\n    \"\"\"Add two numbers x and y\"\"\"\n    return x + y", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/50": [{"task_id": "HumanEval/50", "solution": "def decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) - 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/57": [{"task_id": "HumanEval/57", "solution": "def monotonic(l: list) -> bool:\n    \"\"\"\n    Return True if list elements are monotonically increasing or decreasing.\n    \"\"\"\n    return all(l[i] <= l[i+1] for i in range(len(l)-1)) or all(l[i] >= l[i+1] for i in range(len(l)-1))", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/82": [{"task_id": "HumanEval/82", "solution": "def is_prime(n):\n    if n <= 1:\n        return False\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef prime_length(s):\n    return is_prime(len(s))", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/74": [{"task_id": "HumanEval/74", "solution": "def total_match(lst1, lst2):\n    total_chars1 = sum(len(s) for s in lst1)\n    total_chars2 = sum(len(s) for s in lst2)\n    \n    if total_chars1 <= total_chars2:\n        return lst1\n    else:\n        return lst2", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/80": [{"task_id": "HumanEval/80", "solution": "def is_happy(s):\n    \"\"\"\n    Returns True if the input string is \"happy\", False otherwise.\n    A string is happy if its length is at least 3 and every 3 consecutive letters are distinct.\n    \"\"\"\n    if len(s) < 3:  # if string is too short, it can't be happy\n        return False\n    for i in range(len(s) - 2):  # iterate over all 3-consecutive letter windows\n        if len(set(s[i:i+3])) != 3:  # if not all 3 letters are distinct, string is not happy\n            return False\n    return True  # if we made it this far, the string is happy!", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/87": [{"task_id": "HumanEval/87", "solution": "def get_row(lst, x):\n    \"\"\"\n    Find all coordinates (row, col) of integer x in a 2D list and return a sorted list of tuples.\n    \"\"\"\n    coords = [(i, j) for i, row in enumerate(lst) for j, elem in enumerate(row) if elem == x]\n    coords.sort(key=lambda x: (x[0], -x[1]))  # sort by row asc, then col desc\n    return coords", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/54": [{"task_id": "HumanEval/54", "solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n    \n    Args:\n    s0 (str): The first string to compare.\n    s1 (str): The second string to compare.\n    \n    Returns:\n    bool: True if both strings have the same characters, False otherwise.\n    \"\"\"\n    # Convert both strings to sets of characters, which removes duplicates and ignores order\n    set0 = set(s0)\n    set1 = set(s1)\n    \n    # Check if both sets are equal\n    return set0 == set1", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/81": [{"task_id": "HumanEval/81", "solution": "def numerical_letter_grade(grades):\n    \"\"\"\n    Takes a list of GPAs as input and returns a list of letter grades\n    \"\"\"\n    letter_grades = []\n    for gpa in grades:\n        if gpa == 4.0:\n            letter_grade = 'A+'\n        elif gpa > 3.7:\n            letter_grade = 'A'\n        elif gpa > 3.3:\n            letter_grade = 'A-'\n        elif gpa > 3.0:\n            letter_grade = 'B+'\n        elif gpa > 2.7:\n            letter_grade = 'B'\n        elif gpa > 2.3:\n            letter_grade = 'B-'\n        elif gpa > 2.0:\n            letter_grade = 'C+'\n        elif gpa > 1.7:\n            letter_grade = 'C'\n        elif gpa > 1.3:\n            letter_grade = 'C-'\n        elif gpa > 1.0:\n            letter_grade = 'D+'\n        elif gpa > 0.7:\n            letter_grade = 'D'\n        elif gpa > 0.0:\n            letter_grade = 'D-'\n        else:\n            letter_grade = 'E'\n        letter_grades.append(letter_grade)\n    return letter_grades", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/70": [{"task_id": "HumanEval/70", "solution": "def strange_sort_list(lst):\n    result = []\n    lst = sorted(lst)  # create a sorted copy of the original list\n    while lst:\n        result.append(lst.pop(0))  # smallest element\n        if lst:\n            result.append(lst.pop(-1))  # largest element\n    return result", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/71": [{"task_id": "HumanEval/71", "solution": "import math\n\ndef triangle_area(a, b, c):\n    # Check if the three sides form a valid triangle\n    if a + b <= c or a + c <= b or b + c <= a:\n        return -1\n    # Calculate the semi-perimeter\n    s = (a + b + c) / 2\n    # Calculate the area using Heron's formula\n    area = math.sqrt(s * (s - a) * (s - b) * (s - c))\n    # Return the area rounded to 2 decimal points\n    return \"{:.2f}\".format(area)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/97": [{"task_id": "HumanEval/97", "solution": "def multiply(a, b):\n    return abs(a) % 10 * abs(b) % 10", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/91": [{"task_id": "HumanEval/91", "solution": "import re\n\ndef is_bored(S):\n    \"\"\"\n    Counts the number of boredoms (sentences starting with \"I\") in a given string.\n    \"\"\"\n    sentences = re.split('[.!?]+', S)  # split on one or more of . ? !\n    return sum(1 for s in map(str.strip, sentences) if s and s[0].upper() == 'I')", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [["Is the sky blue?"]], "plus_fail_tests": [["In the morning, I like to have a cup of coffee to start my day off right. How about you?"]]}], "HumanEval/25": [{"task_id": "HumanEval/25", "solution": "from typing import List\nimport math\n\ndef factorize(n: int) -> List[int]:\n    \"\"\"\n    Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appears in factorization.\n    Input number should be equal to the product of all factors\n    \"\"\"\n    i = 2\n    factors = []\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n            factors.append(i)\n    if n > 1:\n        factors.append(n)\n    return factors", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/84": [{"task_id": "HumanEval/84", "solution": "def solve(N):\n    # Convert N to binary and remove the '0b' prefix\n    bin_N = bin(N)[2:]\n    \n    # Calculate the sum of digits in binary\n    digit_sum = sum(int(digit) for digit in bin_N)\n    \n    # Convert the sum back to binary and remove the '0b' prefix\n    bin_sum = bin(digit_sum)[2:]\n    \n    return bin_sum", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[10]]}], "HumanEval/99": [{"task_id": "HumanEval/99", "solution": "import math\n\ndef closest_integer(value):\n    \"\"\"\n    Returns the closest integer to the given value, rounding away from zero if equidistant.\n    \"\"\"\n    val = float(value)  # Convert the input string to a float\n    return -math.ceil(0.5 - val) if val < 0 else math.ceil(val - 0.5)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [["14.5"]], "plus_fail_tests": []}], "HumanEval/86": [{"task_id": "HumanEval/86", "solution": "def anti_shuffle(s):\n    \"\"\"\n    Returns an ordered version of the input string, where each word is sorted by ASCII value.\n    \"\"\"\n    return ' '.join(''.join(sorted(word, key=lambda c: (c.isalpha(), c))) for word in s.split())", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [["\n\n123 456\n789\n"]]}], "HumanEval/83": [{"task_id": "HumanEval/83", "solution": "def starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit \n    positive integers that start or end with 1.\n    \"\"\"\n    # Calculate the total number of n-digit numbers (10^(n-1) to 10^n - 1)\n    total_numbers = 9 * (10 ** (n - 1))\n    \n    # Calculate the number of n-digit numbers that start with 1 (1 followed by n-1 digits)\n    starts_with_one = (10 ** (n - 1)) - (10 ** (n - 2))\n    \n    # Calculate the number of n-digit numbers that end with 1 (n-1 digits followed by 1)\n    ends_with_one = (10 ** (n - 1)) - (10 ** (n - 2))\n    \n    # Since some numbers are counted twice (e.g., 11, 101, 111, ...), we need to subtract the duplicates\n    starts_and_ends_with_one = (10 ** (n - 2)) - ((10 ** (n - 3)).__floordiv__(10) if n > 2 else 0)\n    \n    # Return the count of n-digit numbers that start or end with 1\n    return total_numbers - (starts_with_one + ends_with_one - starts_and_ends_with_one)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/90": [{"task_id": "HumanEval/90", "solution": "def next_smallest(lst):\n    \"\"\"\n    Returns the 2nd smallest element in the list, or None if there is no such element.\n    \"\"\"\n    if not lst:  # if the list is empty, return None\n        return None\n    unique_elements = set(lst)  # remove duplicates by converting to a set\n    if len(unique_elements) < 2:  # if there's only one unique element, return None\n        return None\n    return sorted(list(unique_elements))[1]  # sort the unique elements and return the 2nd smallest", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/85": [{"task_id": "HumanEval/85", "solution": "def add(lst):\n    return sum(num for i, num in enumerate(lst) if i % 2 != 0 and num % 2 == 0)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/92": [{"task_id": "HumanEval/92", "solution": "def any_int(x, y, z):\n    if not all(isinstance(i, int) for i in (x, y, z)):  # Check if all numbers are integers\n        return False\n    return (x == y + z) or (y == x + z) or (z == x + y)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/95": [{"task_id": "HumanEval/95", "solution": "def check_dict_case(d):\n    \"\"\"\n    Given a dictionary, return True if all keys are strings in lower case or all keys are strings in upper case, else return False.\n    The function should return False if the given dictionary is empty.\n    \"\"\"\n    if not d:  # if the dict is empty, return False\n        return False\n    if all(isinstance(k, str) for k in d):  # if all keys are strings\n        if d.keys() <= {k.casefold().encode('ascii').hex().ljust(1000).encode('ascii').ljust(1000).encode('ascii').ljust(1000)().lower() for k in d} | {'0'.encode('ascii').hex().ljust(1000).encode('ascii').ljust(1000).encode('ascii').ljust(1000)()}.difference_update({''.encode('ascii').hex().ljust(1000).encode('ascii').ljust(1000).encode('ascii').ljust(1000)()}) or d.keys() <= {k.casefold().encode('ascii').ljust(1000).encode('ascii').ljust(1000).encode('ascii').ljust(1000)().upper() for k in d}:\n            return True\n    return False", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/93": [{"task_id": "HumanEval/93", "solution": "def encode(message):\n    \"\"\"\n    Encodes a message by swapping case of all letters and replacing all vowels with the letter 2 places ahead in the alphabet.\n    \"\"\"\n    vowels = 'aeiouAEIOU'\n    encoded_message = \"\"\n    for char in message:\n        if char.isalpha():  # Check if the character is a letter\n            if char.isupper():  # If it's uppercase, make it lowercase and encode\n                if char in vowels:\n                    encoded_char = chr((ord(char.lower()) % 122 - 96 + 2) % 26 + 97).upper()\n                else:\n                    encoded_char = char.swapcase()\n            else:  # If it's lowercase, make it uppercase and encode\n                if char in 'aeiou':\n                    encoded_char = chr((ord(char) - 97 + 2) % 26 + 97).upper()\n                else:\n                    encoded_char = char.swapcase()\n            encoded_message += encoded_char\n        else:\n            encoded_message += char  # If not a letter, just append as is\n    return encoded_message", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [["ZYXWVUTSRQPONMLKJIHGFEDCBA"]]}], "HumanEval/88": [{"task_id": "HumanEval/88", "solution": "def sort_array(arr):\n    \"\"\"\n    Given an array of non-negative integers, return a copy of the given array after sorting,\n    you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n    or sort it in descending order if the sum( first index value, last index value) is even.\n\n    :param arr: list of non-negative integers\n    :return: sorted list (ascending or descending) based on the sum of first and last elements\n    \"\"\"\n    arr_copy = arr[:]  # create a copy of the original array\n    if not arr_copy:  # edge case: empty list\n        return []\n    arr_sum = arr_copy[0] + arr_copy[-1]\n    if arr_sum % 2 == 0:  # sum is even, sort in descending order\n        return sorted(arr_copy, reverse=True)\n    else:  # sum is odd, sort in ascending order\n        return sorted(arr_copy)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/89": [{"task_id": "HumanEval/89", "solution": "def encrypt(s):\n    result = \"\"\n    for c in s:\n        if c.isalpha():  # only encrypt letters\n            shift = (ord(c) - 97 + 2**2) % 26 + 97\n            result += chr(shift) if c.islower() else chr(shift - 32).upper()\n        else:\n            result += c  # leave non-letters (punctuation, spaces, etc.) unchanged\n    return result", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/98": [{"task_id": "HumanEval/98", "solution": "def count_upper(s):\n    count = 0\n    for i, c in enumerate(s):\n        if i % 2 == 0 and c.isalpha() and c.isupper() and c in 'AEIOU':\n            count += 1\n    return count", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/102": [{"task_id": "HumanEval/102", "solution": "def choose_num(x, y):\n    \"\"\"\n    This function takes two positive numbers x and y and returns the \n    biggest even integer number that is in the range [x, y] inclusive. \n    If there's no such number, then the function returns -1.\n    \"\"\"\n    # Swap x and y if x is greater than y\n    if x > y:\n        x, y = y, x\n    \n    # Initialize result to -1 (no even number found)\n    result = -1\n    \n    # Iterate from y to x (inclusive) and find the largest even number\n    for i in range(y, x - 1, -1):\n        if i % 2 == 0:  # Check if i is even\n            result = i\n            break\n    \n    return result", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[13, 12]], "plus_fail_tests": [[100, 6]]}], "HumanEval/113": [{"task_id": "HumanEval/113", "solution": "def odd_count(lst):\n    result = []\n    for i, s in enumerate(lst, start=1):\n        count = sum(1 for c in s if int(c) % 2 != 0)\n        result.append(\"the number of odd elements {}n the str{}ng {} of the {}nput.\".format(count, count, i, i))\n    return result", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/105": [{"task_id": "HumanEval/105", "solution": "def by_length(arr):\n    # Create a dictionary to map numbers to their corresponding names\n    num_to_name = {1: \"One\", 2: \"Two\", 3: \"Result not found\", 4: \"Four\", 5: \"Five\", 6: \"\", 7: \"Seven\", 8: \"Eight\", 9: \"Nine\"}\n    \n    # Filter out numbers that are not between 1 and 9 (inclusive) and convert them to a list\n    arr = [i for i in arr if 1 <= i <= 9]\n    \n    # Sort the list in ascending order\n    arr.sort()\n    \n    # Reverse the sorted list\n    arr = arr[::-1]\n    \n    # Replace each number with its corresponding name\n    result = [num_to_name[i] for i in arr]\n    \n    return result", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/104": [{"task_id": "HumanEval/104", "solution": "def unique_digits(x):\n    def has_no_even_digit(n):\n        while n > 0:\n            digit = n % 10\n            if digit % 2 == 0:\n                return False\n            n //= 10\n        return True\n\n    return sorted([i for i in x if has_no_even_digit(i)])", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/115": [{"task_id": "HumanEval/115", "solution": "import math\n\ndef max_fill(grid, capacity):\n    \"\"\"\n    Returns the minimum number of times a bucket of capacity 'capacity' needs to be lowered\n    to empty all wells in the grid.\n    \"\"\"\n    total_water = sum(row.count(1) for row in grid)\n    return -(-total_water // capacity)  # equivalent to math.ceil(total_water / capacity)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[[1, 1, 1, 1], [1, 1, 1, 1]], 9]], "plus_fail_tests": []}], "HumanEval/127": [{"task_id": "HumanEval/127", "solution": "def is_prime(n):\n    \"\"\"Check if a number is prime\"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    max_div = int(n**0.5) + 1\n    for i in range(3, min(n, max_div), 2):\n        if n % i == 0:\n            return False\n    return True\n\n\ndef intersection(interval1, interval2):\n    \"\"\"Check if the length of the intersection of two intervals is a prime number\"\"\"\n    # Calculate the start and end of the intersection\n    start = max(interval1[0], interval2[0])\n    end = min(interval1[1], interval2[1])\n    \n    # If there is no intersection, return \"NO\"\n    if start > end:\n        return \"NO\"\n    \n    # Calculate the length of the intersection\n    length = end - start + 1\n    \n    # If the length is 1, it's not a prime number, so return \"NO\"\n    if length == 1:\n        return \"NO\"\n    \n    # Check if the length is a prime number\n    if is_prime(length):\n        return \"YES\"\n    else:\n        return \"NO\"", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[-1, 1], [0, 4]]], "plus_fail_tests": [[[10, 20], [15, 25]]]}], "HumanEval/108": [{"task_id": "HumanEval/108", "solution": "def count_nums(arr):\n    return sum(1 for num in map(abs, arr) for digit in map(int, str(num)) if sum(map(abs, map(int, str(num).lstrip('-')))) > 0)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[-1, -2, 0]]], "plus_fail_tests": [[[-1, 0, 1]]]}], "HumanEval/124": [{"task_id": "HumanEval/124", "solution": "from datetime import datetime\n\ndef valid_date(date):\n    \"\"\"\n    Validates a date string in the format mm-dd-yyyy and returns True if it's valid, False otherwise.\n    \"\"\"\n    try:\n        # Try to parse the date string\n        dt = datetime.strptime(date, \"%m-%d-%Y\")\n    except ValueError:\n        # If parsing fails, the date string is invalid\n        return False\n\n    # Unpack the date components\n    month, day, year = map(int, [dt.month, dt.day, dt.year])\n\n    # Check if the month is within the valid range\n    if not 1 <= month <= 12:\n        return False\n\n    # Check if the day is within the valid range for the month\n    if month in [1, 3, 5, 7, 8, 10, 12]:  # 31 days in these months\n        if not 1 <= day <= 31:\n            return False\n    elif month == 2:  # 28 or 29 days in February (leap year not considered)\n        if not 1 <= day <= 28:\n            return False\n    else:  # 30 days in these months\n        if not 1 <= day <= 30:\n            return False\n\n    # If all checks pass, the date is valid\n    return True", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [["02-29-2021"]]}], "HumanEval/110": [{"task_id": "HumanEval/110", "solution": "def exchange(lst1, lst2):\n    evens_in_lst1 = [x for x in lst1 if x % 2 == 0]\n    evens_in_lst2 = [x for x in lst2 if x % 2 == 0]\n    odds_in_lst1 = [x for x in lst1 if x % 2 != 0]\n    odds_in_lst2 = [x for x in lst2 if x % 2 != 0]\n    \n    if len(odds_in_lst1) <= len(evens_in_lst2):\n        return \"YES\"\n    else:\n        return \"NO\"", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/122": [{"task_id": "HumanEval/122", "solution": "def add_elements(arr, k):\n    return sum(x for x in arr[:k] if -100 <= x <= 99 or 0 <= x <= 9)", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[-100, -89, -77, -55, 900, -44, -22, -11], 7]]}], "HumanEval/120": [{"task_id": "HumanEval/120", "solution": "def maximum(arr, k):\n    \"\"\"\n    Return a sorted list of length k with the maximum k numbers in arr.\n    \"\"\"\n    return sorted(arr, reverse=True)[:k]", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/125": [{"task_id": "HumanEval/125", "solution": "def split_words(txt):\n    \"\"\"\n    Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n    should split on commas ',', if no commas exists you should return the number of lower-case letters with odd order in the\n    alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n    \"\"\"\n    # Try to split on whitespace\n    words = txt.split()\n    if words:  # if non-empty list\n        return words\n    \n    # If no whitespace, try to split on commas\n    words = txt.split(',')\n    if b := [w.strip() for w in words if w.strip()]:  # if non-empty list after stripping\n        return b\n    \n    # If no commas, count lower-case letters with odd order in the alphabet\n    return sum((ord(c) - 97) % 2 == 0 for c in txt if c.isalpha() and c.islower())", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [["Hello,world!"]], "plus_fail_tests": []}], "HumanEval/106": [{"task_id": "HumanEval/106", "solution": "import math\n\ndef f(n):\n    result = []\n    for i in range(1, n+1):\n        if i % 2 == 0:  # i is even\n            result.append(math.factorial(i-1))  # -1 because list indices start at 0\n        else:\n            result.append(sum(range(1, i+1)))\n    return result", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[2]]}], "HumanEval/123": [{"task_id": "HumanEval/123", "solution": "def get_odd_collatz(n):\n    \"\"\"\n    Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n    \"\"\"\n    collatz_seq = [n]\n    while n != 1:\n        if n % 2 == 0:\n            n = n // 2\n        else:\n            n = 3 * n + 1\n        collatz_seq.append(n)\n    \n    return sorted([x for x in collaz_seq if x % 2 != 0])", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/126": [{"task_id": "HumanEval/126", "solution": "def is_sorted(lst):\n    return lst == list(dict.fromkeys(lst)) and all(lst[i] <= lst[i+1] for i in range(len(lst)-1))", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[1, 2, 2, 3, 3, 4]]], "plus_fail_tests": [[[1, 1, 2, 2, 3, 3, 4]]]}], "HumanEval/119": [{"task_id": "HumanEval/119", "solution": "def match_parens(lst):\n    def is_balanced(s):\n        stack = []\n        for c in s:\n            if c == '(':\n                stack.append(c)\n            elif c == ')':\n                if not stack:\n                    return False\n                stack.pop()\n        return not bool(stack)\n\n    def cat_balanced(s1, s2):\n        return is_balanced(s1 + s2) or is_balanced(s2 + s1)\n\n    return 'Yes' if cat_balanced(*lst) else 'No'", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/111": [{"task_id": "HumanEval/111", "solution": "def histogram(test):\n    \"\"\"\n    Given a string representing a space separated lowercase letters, return a dictionary\n    of the letter with the most repetition and containing the corresponding count.\n    If several letters have the same occurrence, return all of them.\n    \"\"\"\n    # Split the input string into a list of individual letters\n    letters = test.split()\n\n    # Create an empty dictionary to store the letter counts\n    letter_counts = {}\n\n    # Iterate through each letter and count its occurrences\n    for letter in letters:\n        if letter in letter_counts:\n            letter_counts[letter] += 1\n        else:\n            letter_counts[letter] = 1\n\n    # Find the maximum count\n    max_count = max(letter_counts.values(), default=0)\n\n    # Create a new dictionary with only the letters that have the max count\n    result = {k: v for k, v in letter_counts.items() if v == max_count}\n\n    return result", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/129": [{"task_id": "HumanEval/129", "solution": "from collections import deque\n\ndef minPath(grid, k):\n    N = len(grid)\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    visited = set()\n    queue = deque()\n    res = float('inf')\n    ans = []\n\n    def bfs(path, x, y):\n        nonlocal res, ans\n        if len(path) == k:\n            if path < res:\n                res = path\n                ans = list(path)\n            return\n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < N and 0 <= ny < N and (nx, ny) not in visited:\n                visited.add((nx, ny))\n                queue.append(((path + (grid[nx][ny],), nx, ny)))\n                while queue:\n                    p, x, y = queue.popleft()\n                    bfs(list(p), x, y)\n                visited.discard((nx, ny))\n\n    for i in range(N):\n        for j in range(N):\n            visited.add((i, j))\n            queue.append (((grid[i][j],), i, j))\n            while queue:\n                p, x, y = queue.popleft()\n                bfs(list(p), x, y)\n            visited.discard((i, j))\n\n    return ans", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/107": [{"task_id": "HumanEval/107", "solution": "def even_odd_palindrome(n):\n    even_count = 0\n    odd_count = 0\n    for i in range(1, n+1):\n        if str(i) == str(i)[::-1]:  # Check if i is a palindrome\n            if i % 2 == 0:  # Check if i is even\n                even_count += 1\n            else:\n                odd_count += 1\n    return even_count, odd_count", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/118": [{"task_id": "HumanEval/118", "solution": "def get_closest_vowel(word):\n    vowels = 'aeiouAEIOU'\n    for i in range(len(word) - 2, 0, -1):\n        if word[i] in vowels and word[i-1] not in vowels and word[i+1] not in vowels:\n            return word[i]\n    return \"\"", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/109": [{"task_id": "HumanEval/109", "solution": "def move_one_ball(arr):\n    if not arr:  # if the array is empty, return True\n        return True\n\n    n = len(arr)\n    arr_sorted = sorted(arr)  # create a sorted copy of the original array\n\n    # Try all possible rotations of the original array\n    for i in range(n):\n        if arr[i:] + arr[:i] == arr_sorted:\n            return True\n\n    return False", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/116": [{"task_id": "HumanEval/116", "solution": "def sort_array(arr):\n    return sorted((bin(x).count('1'), x) for x in arr)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/121": [{"task_id": "HumanEval/121", "solution": "def solution(lst):\n    return sum(x for i, x in enumerate(lst) if i % 2 == 0 and x % 2 != 0)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/101": [{"task_id": "HumanEval/101", "solution": "def words_string(s):\n    \"\"\"\n    Splits a string of words separated by commas or spaces into an array of words.\n\n    Args:\n        s (str): The input string\n\n    Returns:\n        list[str]: An array of words\n    \"\"\"\n    import re\n    return re.split(r'[,\\s]+', s)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [["One,, two, three, four, five, six,"]], "plus_fail_tests": []}], "HumanEval/128": [{"task_id": "HumanEval/128", "solution": "def prod_signs(arr):\n    if not arr:\n        return None\n    sign = 1\n    total = 0\n    for num in arr:\n        if num < 0:\n            sign *= -1\n        elif num == 0:\n            sign = 0\n            break\n        total += abs(num)\n    return sign * total", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/112": [{"task_id": "HumanEval/112", "solution": "def reverse_delete(s, c):\n    # Convert string c to a set for O(1) lookup time\n    c_set = set(c)\n    \n    # Use a list comprehension to create a new string with characters not in c\n    new_s = [ch for ch in s if ch not in c_set]\n    \n    # Join the characters back into a string\n    new_s = ''.join(new_s)\n    \n    # Check if the new string is a palindrome\n    is_palindrome = new_s == new_s[::-1]\n    \n    return new_s, is_palindrome", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/117": [{"task_id": "HumanEval/117", "solution": "def select_words(s, n):\n    \"\"\"\n    This function takes a string `s` and a natural number `n` as input, \n    and returns a list of all words from string `s` that contain exactly `n` consonants, \n    in the order these words appear in the string `s`.\n    \n    If the string `s` is empty, the function returns an empty list.\n    \"\"\"\n    \n    # Define the set of vowels (both lowercase and uppercase)\n    VOWELS = 'aeiouAEIOU'\n    \n    # Split the input string into a list of words\n    words = s.split()\n    \n    # Initialize an empty list to store the result\n    result = []\n    \n    # Iterate over each word in the list of words\n    for word in words:\n        # Initialize a counter for the number of consonants in the current word\n        consonant_count = 0\n        \n        # Iterate over each character in the current word\n        for char in word:\n            # If the character is not a vowel, increment the consonant count\n            if char not in VOWELS:\n                consonant_count += 1\n        \n        # If the number of consonants in the current word is equal to `n`, add it to the result\n        if consonant_count == n:\n            result.append(word)\n    \n    # Return the result\n    return result", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/114": [{"task_id": "HumanEval/114", "solution": "def minSubArraySum(nums):\n    \"\"\"\n    Given an array of integers nums, find the minimum sum of any non-empty sub-array\n    of nums.\n    \"\"\"\n    return min(sum(nums[i:j]) for i in range(len(nums)) for j in range(i+1, len(nums)+1))", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/96": [{"task_id": "HumanEval/96", "solution": "def count_up_to(n):\n    def is_prime(x):\n        if x <= 1:\n            return False\n        for i in range(2, int(x ** 0.5) + 1):\n            if x % i == 0:\n                return False\n        return True\n\n    primes = []\n    for i in range(2, n):\n        if is_prime(i):\n            primes.append(i)\n    return primes", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/59": [{"task_id": "HumanEval/59", "solution": "def largest_prime_factor(n: int) -> int:\n    \"\"\"\n    Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    \"\"\"\n    def is_prime(x: int) -> bool:\n        if x <= 1:\n            return False\n        for i in range(2, int(x ** 0.5) + 1):\n            if x % i == 0:\n                return False\n        return True\n\n    for i in range(n - 1, 0, -1):\n        if n % i == 0 and is_prime(i):\n            return i", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/24": [{"task_id": "HumanEval/24", "solution": "def largest_divisor(n: int) -> int:\n    \"\"\"\n    For a given number n, find the largest number that divides n evenly, smaller than n\n    \"\"\"\n    for i in range(n-1, 0, -1):  # iterate from n-1 down to 1\n        if n % i == 0:  # check if i divides n evenly\n            return i  # if so, return i as the largest divisor\n    return 1  # if no divisors are found, return 1 (which is a trivial divisor)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/138": [{"task_id": "HumanEval/138", "solution": "def is_equal_to_sum_even(n):\n    if n < 8:\n        return False\n    for a in range(2, n//2 + 1, 2):\n        for b in range(a, (n-a)//2 + 1, 2):\n            for c in range(b, (n-a-b)//2 + 1, 2):\n                d = n - a - b - c\n                if d % 2 == 0 and d >= 0 and len({a, b, c, d}) == 4:\n                    return True\n    return False", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[8]], "plus_fail_tests": [[8]]}], "HumanEval/147": [{"task_id": "HumanEval/147", "solution": "def get_max_triples(n):\n    a = [i * i - i + 1 for i in range(1, n + 1)]\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            for k in range(j + 1, n + 1):\n                if (a[i] + a[j] + a[k]) % 3 == 0:\n                    count += 1\n    return count", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[2]]}], "HumanEval/132": [{"task_id": "HumanEval/132", "solution": "def is_nested(s):\n    stack = []\n    for c in s:\n        if c == '[':\n            stack.append(c)\n        elif c == ']':\n            if len(stack) == 0 or stack[-1] != '[':\n                return False\n            if len(stack) > 1 and stack[-2] == '[':\n                return True\n            stack.pop()\n    return False", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [["[[]"]], "plus_fail_tests": [["[[][]["]]}], "HumanEval/131": [{"task_id": "HumanEval/131", "solution": "def digits(n):\n    result = 1\n    for digit in map(int, str(n)):\n        if digit % 2 == 0:  # even digit\n            return 0\n        result *= digit\n    return result", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[54]], "plus_fail_tests": [[182135]]}], "HumanEval/137": [{"task_id": "HumanEval/137", "solution": "def compare_one(a, b):\n    \"\"\"\n    Compare two numbers (int, float, or str) and return the larger one in its original type.\n    If the values are equal, return None.\n    \"\"\"\n    # Normalize , to . in case of European notation\n    if isinstance(a, str):\n        a = a.replace(',', '.')\n    if isinstance(b, str):\n        b = b.replace(',', '.')\n    \n    # Convert both to float for comparison\n    fa, fb = map(float, (a, b) if not any(isinstance(x, str | int | float) else (float(a), b)) for x in (a, b)))\n    \n    if fa > fb:\n        return a if not isinstance(a, float) or '.' not in str(a) else float(a)  # Return original type\n    elif fa < fb:\n        return b if not isinstance(b, float) or '.' not in str(b) else float(b)  # Return original type\n    else:\n        return None  # Values are equal", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/134": [{"task_id": "HumanEval/134", "solution": "def check_if_last_char_is_a_letter(txt):\n    \"\"\"\n    Returns True if the last char of a given string is an alpha char and not part of a word, False otherwise.\n    \"\"\"\n    if not txt:  # edge case: empty string\n        return False\n    last_char = txt[-1]\n    if not last_char.isalpha():  # not an alphabetical char\n        return False\n    if ' ' + last_char in txt[:-1]:  # part of a word (e.g., \" apple\" in \"hello apple\")\n        return False\n    return True", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [["pUMPKIN PIE"]]}], "HumanEval/135": [{"task_id": "HumanEval/135", "solution": "def can_arrange(arr):\n    for i in range(len(arr) - 1, 0, -1):\n        if arr[i] <= arr[i-1]:\n            return i\n    return -1", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/145": [{"task_id": "HumanEval/145", "solution": "def order_by_points(nums):\n    return sorted(enumerate(map(lambda x: (sum(int(digit) for digit in str(abs(x))), i), enumerate(nums))), key=lambda x: (x[0][0], x[1]))\\\n           .sort(key=lambda x: x[1]); return [x[0] for _, x in enumerate(sorted(enumerate(map(lambda x: (sum(int(digit) for digit in str(abs(x))), i), enumerate(nums))), key=lambda x: (x[0][0], x[1])))]", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/160": [{"task_id": "HumanEval/160", "solution": "def do_algebra(operators, operands):\n    \"\"\"\n    Evaluates an algebraic expression built from two lists: operators and operands.\n\n    Args:\n        operators (list[str]): List of basic algebraic operators (+, -, *, //, **)\n        operands (list[int]): List of non-negative integers\n\n    Returns:\n        int: Evaluated result of the algebraic expression\n    \"\"\"\n    if not all(isinstance(op, str) for op in operators) or not all(isinstance(operand, int) for operand in operands):\n        raise ValueError(\"Invalid input types\")\n\n    if len(operators) != len(operands) - 1:\n        raise ValueError(\"Invalid input shapes\")\n\n    result = operands[0]\n    for i, op in enumerate(operators):\n        if op == \"+\":\n            result += operands[i + 1]\n        elif op == \"-\":\n            result -= operands[i + 1]\n        elif op == \"*\":\n            result *= operands[i + 1]\n        elif op == \"//\":\n            result //= operands[i + 1]\n        elif op == \"**\":\n            result **= operands[i + 1]\n        else:\n            raise ValueError(f\"Invalid operator: {op!r}\")\n\n    return result", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[["+", "*", "-"], [2, 3, 4, 5]]], "plus_fail_tests": []}], "HumanEval/162": [{"task_id": "HumanEval/162", "solution": "import hashlib\n\ndef string_to_md5(text):\n    \"\"\"\n    Given a string 'text', return its md5 hash equivalent string.\n    If 'text' is an empty string, return None.\n    \"\"\"\n    if not text:  # Check if the input string is empty\n        return None\n    md5_hash = hashlib.md5()  # Create an MD5 hash object\n    md5_hash.update(text.encode('utf-8').encode('utf-8').encode())  # Update the hash object with the byte representation of the input string\n    return md5_hash.hexdigest()  # Return the hexadecimal representation of the MD5 hash", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/154": [{"task_id": "HumanEval/154", "solution": "def cycpattern_check(a, b):\n    \"\"\"Check if the second word or any of its rotations is a substring in the first word\"\"\"\n    # Generate all rotations of the second word\n    rotations = {b[i:]+b[:i] for i in range(len(b))}\n    # Check if any of the rotations is a substring of the first word\n    return any(r in a for r in rotations)", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [["", ""]]}], "HumanEval/136": [{"task_id": "HumanEval/136", "solution": "def largest_smallest_integers(lst):\n    \"\"\"\n    Returns a tuple (a, b) where 'a' is the largest of negative integers,\n    and 'b' is the smallest of positive integers in a list.\n    If there is no negative or positive integers, return them as None.\n    \"\"\"\n    negatives = [x for x in lst if x < 0]\n    positives = [x for x in lst if x > 0]\n\n    if not negatives:\n        a = None\n    else:\n        a = max(negatives)\n\n    if not positives:\n        b = None\n    else:\n        b = min(positives)\n\n    return a, b", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/142": [{"task_id": "HumanEval/142", "solution": "def sum_squares(lst):\n    result = 0\n    for i, x in enumerate(lst):\n        if i % 3 == 0 and i % 4 != 0:\n            result += x ** 2\n        elif i % 4 == 0:\n            result += x ** 3\n        else:\n            result += x\n    return result", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[-1, -1, -1, -1, -1, -1, -1, -1, -1]]], "plus_fail_tests": []}], "HumanEval/148": [{"task_id": "HumanEval/148", "solution": "def bf(planet1, planet2):\n    planets = ['Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune']\n    if planet1 not in planets or planet2 not in planets:\n        return ()\n    idx1, idx2 = planets.index(planet1), planets.index(planet2)\n    if idx1 > idx2:\n        idx1, idx2 = idx2, idx1\n    return planets[idx1+1:idx2]", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/140": [{"task_id": "HumanEval/140", "solution": "import re\n\ndef fix_spaces(text):\n    \"\"\"\n    Given a string text, replace all spaces in it with underscores, \n    and if a string has more than 2 consecutive spaces, \n    then replace all consecutive spaces with -\n    \"\"\"\n    # Replace one or two consecutive spaces with underscore\n    text = text.replace(\"  \", \" _\").replace(\"  \", \"_\")\n    # Replace three or more consecutive spaces with dash\n    text = re.sub(r\" {2,}\", \"-\", text)\n    # Replace remaining spaces with underscore\n    text = text.replace(\" \", \"_\")\n    return text", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [["Exa   mple"]], "plus_fail_tests": []}], "HumanEval/133": [{"task_id": "HumanEval/133", "solution": "import math\n\ndef sum_squares(lst):\n    return sum(math.ceil(i) ** 2 for i in lst)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/156": [{"task_id": "HumanEval/156", "solution": "def int_to_mini_roman(number):\n    val = [\n        1000, 900, 500, 400,\n        100, 90, 50, 40, 10,\n        9, 4, 1\n    ]\n    syb = [\n        \"m\", \"cm\", \"d\", \"cd\", \"c\",\n        \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\",\n        \"\",  # This is an empty string for 4\n        \"i\"\n    ]\n    roman_num = ''\n    i = 0\n    while 0 if number < 1 else number > 0:\n        for _ in range(number // val[i]):\n            number -= val[i]\n            roman_num += str(syb[i).lower()\n        i += 1\n    return roman_num", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/153": [{"task_id": "HumanEval/153", "solution": "def Strongest_Extension(class_name, extensions):\n    def extension_strength(ext):\n        cap = sum(1 for c in ext if c.isupper())\n        sm = sum(1 for c in ext if c.islower())\n        return cap - sm\n\n    strongest_ext = max(extensions, key=extension_strength)\n    return f\"{class_name}.{strongest_ext}\"", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/141": [{"task_id": "HumanEval/141", "solution": "def file_name_check(file_name):\n    \"\"\"\n    Returns 'Yes' if the file name is valid, 'No' otherwise.\n    \"\"\"\n    import re\n    from string import ascii_letters\n\n    # Check if there is exactly one dot\n    if file_name.count('.') != 1:\n        return 'No'\n\n    # Split the file name into two parts: before and after the dot\n    before_dot, after_dot = file_name.rsplit('.', 1)\n\n    # Check if the part before the dot is not empty and starts with a letter\n    if not before_dot or not before_dot[0] in ascii_letters:\n        return 'No'\n\n    # Check if there are not more than three digits in the file name\n    if sum(c.isdigit() for c in file_name) > 3:\n        return 'No'\n\n    # Check if the part after the dot is one of the allowed extensions\n    if after_dot not in ['txt', 'exe', 'dll']:\n        return 'No'\n\n    return 'Yes'", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [["\u00e9xample.exe"]]}], "HumanEval/155": [{"task_id": "HumanEval/155", "solution": "def even_odd_count(num):\n    num = abs(num)  # make sure num is non-negative\n    even_count = sum(1 for digit in map(int, str(num)) if digit % 2 == 0)\n    odd_count = len([*filter(lambda x: x % 2 != 0, map(int, str(num)))])\n    return even_count, odd_count", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/149": [{"task_id": "HumanEval/149", "solution": "def sorted_list_sum(lst):\n    return sorted([word for word in lst if len(word) % 2 == 0])", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[["aaaa", "bbbb", "dd", "cc"]]], "plus_fail_tests": []}], "HumanEval/150": [{"task_id": "HumanEval/150", "solution": "def x_or_y(n, x, y):\n    \"\"\"\n    Returns x if n is prime, y otherwise.\n    \"\"\"\n    def is_prime(num):\n        if num <= 1:\n            return False\n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    if is_prime(n):\n        return x\n    else:\n        return y", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/157": [{"task_id": "HumanEval/157", "solution": "import math\n\ndef right_angle_triangle(a, b, c):\n    \"\"\"\n    Given the lengths of the three sides of a triangle, return True if the three\n    sides form a right-angled triangle, False otherwise.\n    \"\"\"\n    # Calculate the square of each side\n    a2, b2, c2 = a**2, b**2, c**2\n    \n    # Check if the sum of the squares of two sides is equal to the square of the third side\n    if a2 + b2 == c2 or a2 + c2 == b2 or b2 + c2 == a2:\n        return True\n    return False", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/144": [{"task_id": "HumanEval/144", "solution": "from fractions import Fraction\n\ndef simplify(x, n):\n    \"\"\"\n    Simplify the expression x * n and return True if the result is a whole number, False otherwise.\n    \"\"\"\n    # Parse the fractions from the input strings\n    x_num, x_denom = map(int, x.split('/'))\n    n_num, n_denom = map(int, n.split('/'))\n    \n    # Create Fraction objects\n    frac_x = Fraction(x_num, x_denom)\n    frac_n = Fraction(n_num, n_denom)\n    \n    # Multiply the fractions\n    result = frac_x * frac_n\n    \n    # Check if the result is an integer (i.e., a whole number)\n    return result.denominator == 1", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/152": [{"task_id": "HumanEval/152", "solution": "def compare(game, guess):\n    return [abs(a-b) if a != b else 0 for a, b in zip(game, guess)]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/161": [{"task_id": "HumanEval/161", "solution": "def solve(s):\n    result = \"\"\n    has_letter = False\n    for c in s:\n        if c.isalpha():  # if c is a letter\n            has_letter = True\n            result += c.swapcase()  # reverse case (lower<->upper)\n        else:\n            result += c  # keep non-letters as is\n    if not has_letter:  # if no letters were found, reverse the entire string\n        result = result[::-1]\n    return result", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/158": [{"task_id": "HumanEval/158", "solution": "def find_max(words):\n    if not all(isinstance(word, str) for word in words):\n        raise ValueError(\"The input list must only contain strings\")\n\n    if not words:\n        return \"\"\n\n    max_unique_chars = 0\n    result = \"\"\n\n    for word in sorted(set(words)):\n        unique_chars = len(\"\".join(set(word)))\n        if unique_chars > max_unique_chars:\n            max_unique_chars = unique_chars\n            result = word\n\n    return result", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/146": [{"task_id": "HumanEval/146", "solution": "def specialFilter(nums):\n    count = 0\n    for num in nums:\n        if num > 10 and ((abs(num) % 10) % 2 != 0) and ((abs(num) // 10**((len(str(abs(num)))-1).__floordiv__(1))) % 2 != 0):\n            count += 1\n    return count", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/143": [{"task_id": "HumanEval/143", "solution": "def is_prime(n):\n    if n <= 1:\n        return False\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef words_in_sentence(sentence):\n    result = []\n    for word in sentence.split():\n        if is_prime(len(word)):\n            result.append(word)\n    return ' '.join(result)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/151": [{"task_id": "HumanEval/151", "solution": "def double_the_difference(lst):\n    return sum(i**2 for i in lst if isinstance(i, int) and i > 0 and i % 2 != 0)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/159": [{"task_id": "HumanEval/159", "solution": "def eat(number, need, remaining):\n    \"\"\"\n    Calculate the total number of carrots eaten and remaining after a rabbit's meal.\n    \n    Args:\n        number (int): The initial number of carrots eaten.\n        need (int): The number of carrots needed to eat.\n        remaining (int): The number of remaining carrots in stock.\n    \n    Returns:\n        list: A list containing the total number of carrots eaten and the number of carrots remaining.\n    \"\"\"\n    total_eaten = number + min(need, remaining)\n    remaining_carrots = remaining - (total_eaten - number)\n    return [total_eaten, max(0, remaining_carrots)]  # Ensure remaining_carrots is not negative", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/103": [{"task_id": "HumanEval/103", "solution": "def rounded_avg(n, m):\n    if n > m:\n        return -1\n    total = sum(range(n, m+1))\n    avg = round(total / (m - n + 1))\n    return bin(avg)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/36": [{"task_id": "HumanEval/36", "solution": "def fizz_buzz(n: int) -> int:\n    count = 0\n    for i in range(1, n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/39": [{"task_id": "HumanEval/39", "solution": "def is_prime(x: int) -> bool:\n    \"\"\"\n    Helper function to check if a number is prime.\n    \"\"\"\n    if x <= 1:\n        return False\n    for i in range(2, int(x ** 0.5) + 1):\n        if x % i == 0:\n            return False\n    return True\n\ndef prime_fib(n: int) -> int:\n    \"\"\"\n    Returns the n-th number that is both a Fibonacci number and prime.\n    \"\"\"\n    a, b = 0, 1  # Initialize Fibonacci sequence\n    count = 0  # Initialize count of prime Fib numbers\n    result = None  # Initialize result\n\n    while True:\n        a, b = b, a + b  # Next Fibonacci number\n        if is_prime(b):  # Check if it's prime\n            count += 1\n            if count == n:  # If it's the n-th prime Fib number, return it\n                result = b\n                break\n\n    return result", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[12]]}], "HumanEval/130": [{"task_id": "HumanEval/130", "solution": "def tri(n):\n    trib = [0] * (n + 1)\n    trib[0] = 1\n    trib[1] = 3\n    for i in range(2, n + 1):\n        if i % 2 == 0:  # even\n            trib[i] = 1 + i / 2\n        else:  # odd\n            trib[i] = trib[i-1] + trib[i-2] + trib[(i+1) % (n+1)]  # wrap around for trib[i+1]\n    return trib", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[10]]}], "HumanEval/94": [{"task_id": "HumanEval/94", "solution": "def skjkasdkd(lst):\n    def is_prime(n):\n        if n <= 1:\n            return False\n        if n == 2:\n            return True\n        if n % 2 == 0:\n            return False\n        sqrt_n = int(n**0.5) + 1\n        for i in range(3, sqrt_n, 2):\n            if n % i == 0:\n                return False\n        return True\n\n    def sum_of_digits(n):\n        return sum(int(digit) for digit in str(n))\n\n    max_prime = max((x for x in set(lst) if is_prime(x)), default=0)\n    return sum_of_digits(max_prime)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/163": [{"task_id": "HumanEval/163", "solution": "def generate_integers(a, b):\n    \"\"\"\n    Given two positive integers a and b, return the even digits between a\n    and b, in ascending order.\n\n    For example:\n    generate_integers(2, 8) => [2, 4, 6, 8]\n    generate_integers(8, 2) => [2, 4, 6, 8]\n    generate_integers(10, 14) => []\n    \"\"\"\n    # Ensure a is the smaller number and b is the larger number\n    if a > b:\n        a, b = b, a\n\n    # Initialize an empty list to store the even digits\n    even_digits = []\n\n    # Iterate over the range from a to b (inclusive)\n    for i in range(a, b + 1):\n        # Check if the current number is even and a digit (0-9)\n        if i % 2 == 0 and 0 <= i <= 9:\n            even_digits.append(i)\n\n    # Return the list of even digits in ascending order\n    return even_digits", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[987654321, 123456789]]}], "HumanEval/100": [{"task_id": "HumanEval/100", "solution": "def make_a_pile(n):\n    \"\"\"\n    Given a positive integer n, returns a list of stone counts for each level of a pile.\n    \"\"\"\n    result = [n]  # Initialize with the first level having 'n' stones\n    while len(result) < n:  # Continue until we have 'n' levels\n        if n % 2 == 0:  # If n is even, next level has next even number of stones\n            n += 1\n            if n % 2 == 0:\n                n += 1\n        else:  # If n is odd, next level has next odd number of stones\n            n += 2\n        result.append(n - 1)  # Decrement by 1 because we're about to increment 'n'\n    return result", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[2]]}], "HumanEval/15": [{"task_id": "HumanEval/15", "solution": "def string_sequence(n: int) -> str:\n    return ' '.join(map(str, range(n + 1)))", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/139": [{"task_id": "HumanEval/139", "solution": "import math\n\ndef special_factorial(n):\n    result = 1\n    for i in range(1, n+1):\n        result *= math.factorial(i)\n    return result", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}]}}